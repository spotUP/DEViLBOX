#!/usr/bin/env node
/**
 * Automatically increment minor version in package.json
 * Example: 1.2.0 -> 1.3.0
 */

const fs = require('fs');
const path = require('path');

const PACKAGE_JSON_PATH = path.join(__dirname, '../package.json');

function incrementMinorVersion() {
  try {
    // Read package.json
    const pkg = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, 'utf-8'));
    const oldVersion = pkg.version || '0.0.0';
    
    // Parse version components
    const parts = oldVersion.split('.');
    if (parts.length < 2) {
      console.error(`Invalid version format in package.json: ${oldVersion}`);
      process.exit(1);
    }

    // Increment minor version (middle number)
    const major = parts[0];
    const minor = parseInt(parts[1], 10) + 1;
    const patch = parts[2] || '0';
    
    const newVersion = `${major}.${minor}.0`; // Reset patch to 0 on minor bump
    
    // Update package.json
    pkg.version = newVersion;
    fs.writeFileSync(PACKAGE_JSON_PATH, JSON.stringify(pkg, null, 2) + '\n');
    
    // Update src/constants/version.ts
    const VERSION_TS_PATH = path.join(__dirname, '../src/constants/version.ts');
    if (fs.existsSync(VERSION_TS_PATH)) {
      const versionTsContent = `/**
 * Global application version
 * This is the single source of truth for the version number across the app.
 * AUTO-GENERATED BY increment-minor-version.cjs - DO NOT EDIT MANUALLY
 */
export const APP_VERSION = '${newVersion}';
`;
      fs.writeFileSync(VERSION_TS_PATH, versionTsContent);
      console.log(`Updated ${VERSION_TS_PATH}`);
    }
    
    console.log(`Version updated: ${oldVersion} -> ${newVersion}`);
  } catch (error) {
    console.error('Failed to increment version:', error.message);
    process.exit(1);
  }
}

incrementMinorVersion();
