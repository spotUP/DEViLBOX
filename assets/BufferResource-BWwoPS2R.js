import{w as t,g as e,S as n,u as a,b as s,c as f,d as r,e as o}from"./PixiApp-DUEXYeX_.js";const i={name:"texture-bit",vertex:{header:"\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",main:"\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        ",main:"\n            outColor = textureSample(uTexture, uSampler, vUV);\n        "}},u={name:"texture-bit",vertex:{header:"\n            uniform mat3 uTextureMatrix;\n        ",main:"\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        "},fragment:{header:"\n        uniform sampler2D uTexture;\n\n\n        ",main:"\n            outColor = texture(uTexture, vUV);\n        "}};function v(n,a){for(const e in n.attributes){const s=n.attributes[e],f=a[e];f?(s.format??(s.format=f.format),s.offset??(s.offset=f.offset),s.instance??(s.instance=f.instance)):t(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}!function(t){const{buffers:n,attributes:a}=t,s={},f={};for(const e in n){const t=n[e];s[t.uid]=0,f[t.uid]=0}for(const r in a){const t=a[r];s[t.buffer.uid]+=e(t.format).stride}for(const r in a){const t=a[r];t.stride??(t.stride=s[t.buffer.uid]),t.start??(t.start=f[t.buffer.uid]),f[t.buffer.uid]+=e(t.format).stride}}(n)}const c=[];c[n.NONE]=void 0,c[n.DISABLED]={stencilWriteMask:0,stencilReadMask:0},c[n.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}},c[n.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}},c[n.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}},c[n.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"keep"},stencilBack:{compare:"not-equal",passOp:"keep"}};class d{constructor(t){this._syncFunctionHash=Object.create(null),this._adaptor=t,this._systemCheck()}_systemCheck(){if(!a())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(t){const e=this.getUniformGroupData(t);t.buffer||(t.buffer=new s({data:new Float32Array(e.layout.size/4),usage:f.UNIFORM|f.COPY_DST}))}getUniformGroupData(t){return this._syncFunctionHash[t._signature]||this._initUniformGroup(t)}_initUniformGroup(t){const e=t._signature;let n=this._syncFunctionHash[e];if(!n){const a=Object.keys(t.uniformStructures).map(e=>t.uniformStructures[e]),s=this._adaptor.createUboElements(a),f=this._generateUboSync(s.uboElements);n=this._syncFunctionHash[e]={layout:s,syncFunction:f}}return this._syncFunctionHash[e]}_generateUboSync(t){return this._adaptor.generateUboSync(t)}syncUniformGroup(t,e,n){const a=this.getUniformGroupData(t);t.buffer||(t.buffer=new s({data:new Float32Array(a.layout.size/4),usage:f.UNIFORM|f.COPY_DST}));let r=null;return e||(e=t.buffer.data,r=t.buffer.dataInt32),n||(n=0),a.syncFunction(t.uniforms,e,r,n),!0}updateUniformGroup(t){if(t.isStatic&&!t._dirtyId)return!1;t._dirtyId=0;const e=this.syncUniformGroup(t);return t.buffer.update(),e}destroy(){this._syncFunctionHash=null}}const m=[{type:"mat3x3<f32>",test:t=>void 0!==t.value.a,ubo:"\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ",uniform:"\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        "},{type:"vec4<f32>",test:t=>"vec4<f32>"===t.type&&1===t.size&&void 0!==t.value.width,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        "},{type:"vec2<f32>",test:t=>"vec2<f32>"===t.type&&1===t.size&&void 0!==t.value.x,ubo:"\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        "},{type:"vec4<f32>",test:t=>"vec4<f32>"===t.type&&1===t.size&&void 0!==t.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        "},{type:"vec3<f32>",test:t=>"vec3<f32>"===t.type&&1===t.size&&void 0!==t.value.red,ubo:"\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ",uniform:"\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        "}];function l(t,e,n,a){const s=["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "];let f=0;for(let o=0;o<t.length;o++){const r=t[o],i=r.data.name;let u=!1,v=0;for(let t=0;t<m.length;t++){if(m[t].test(r.data)){v=r.offset/4,s.push(`name = "${i}";`,`offset += ${v-f};`,m[t][e]||m[t].ubo),u=!0;break}}if(!u)if(r.data.size>1)v=r.offset/4,s.push(n(r,v-f));else{const t=a[r.data.type];v=r.offset/4,s.push(`\n                    v = uv.${i};\n                    offset += ${v-f};\n                    ${t};\n                `)}f=v}const r=s.join("\n");return new Function("uv","data","dataInt32","offset",r)}function p(t,e){return`\n        for (let i = 0; i < ${t*e}; i++) {\n            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];\n        }\n    `}const h={f32:"\n        data[offset] = v;",i32:"\n        dataInt32[offset] = v;","vec2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];","vec3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];","vec4<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];","vec2<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];","vec3<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];","vec4<i32>":"\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];","mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];","mat3x3<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];","mat4x4<f32>":"\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }","mat3x2<f32>":p(3,2),"mat4x2<f32>":p(4,2),"mat2x3<f32>":p(2,3),"mat4x3<f32>":p(4,3),"mat2x4<f32>":p(2,4),"mat3x4<f32>":p(3,4)},x={...h,"mat2x2<f32>":"\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    "};class b extends r{constructor({buffer:t,offset:e,size:n}){super(),this.uid=o("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=o("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=t,this.offset=0|e,this.size=n,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=o("resource"),this.emit("change",this)}destroy(t=!1){this.destroyed=!0,t&&this.buffer.destroy(),this.emit("change",this),this.buffer=null,this.removeAllListeners()}}export{b as B,c as G,d as U,h as a,m as b,l as c,u as d,v as e,i as t,x as u};
