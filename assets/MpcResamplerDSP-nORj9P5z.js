async function t(t,e){const{drive:n,mix:a,frequency:r}=e,o=Math.max(t.sampleRate,44100),i=Math.ceil(t.duration*o),c=new OfflineAudioContext(t.numberOfChannels,i,o),l=c.createBufferSource();l.buffer=t;const u=c.createBiquadFilter();u.type="highpass",u.frequency.value=r,u.Q.value=.707;const f=c.createWaveShaper(),h=8192,m=new Float32Array(h),d=n/5;for(let s=0;s<h;s++){const t=2*s/h-1;m[s]=(1+d)*t/(1+d*Math.abs(t))}f.curve=m;const b=c.createBiquadFilter();b.type="highshelf",b.frequency.value=8e3,b.gain.value=4;const g=c.createGain(),C=a/100;g.gain.value=C;const p=c.createGain();p.gain.value=Math.sqrt(1-C),l.connect(p),p.connect(c.destination),l.connect(u),u.connect(f),f.connect(b),b.connect(g),g.connect(c.destination),l.start(0);const M=await c.startRendering();return{buffer:M,dataUrl:await s(M)}}async function e(t,e){const n=new OfflineAudioContext(t.numberOfChannels,t.length,t.sampleRate),a=n.createBufferSource();a.buffer=t;const r=n.createWaveShaper(),o=8192,i=new Float32Array(o),c=Math.pow(10,e/20),l=.2*c;for(let s=0;s<o;s++){const t=2*s/o-1,e=Math.abs(t),n=t<0?-1:1;if(e<c-l)i[s]=0;else if(e<c+l){const a=(e-(c-l))/(2*l);i[s]=n*t*(a*a)}else i[s]=t}r.curve=i,a.connect(r),r.connect(n.destination),a.start(0);const u=await n.startRendering();return{buffer:u,dataUrl:await s(u)}}async function n(t,e){const n=new OfflineAudioContext(2,t.length,t.sampleRate),a=n.createBufferSource();a.buffer=t;const r=n.createGain(),o=n.createGain(),i=n.createDelay(.1);i.delayTime.value=.01+e/100*.025,a.connect(r),r.connect(n.destination),a.connect(i),i.connect(o),o.connect(n.destination),a.start(0);const c=await n.startRendering();return{buffer:c,dataUrl:await s(c)}}async function a(t,e){const n=new OfflineAudioContext(t.numberOfChannels,t.length,t.sampleRate),a=n.createBufferSource();a.buffer=t;const r=n.createBiquadFilter();r.type="highpass",r.frequency.value=3e3,r.Q.value=1.5;const o=n.createGain();o.gain.value=e/100*1.5;const i=n.createGain();i.gain.value=1,a.connect(i),i.connect(n.destination),a.connect(r),r.connect(o),o.connect(n.destination),a.start(0);const c=await n.startRendering();return{buffer:c,dataUrl:await s(c)}}async function r(t){const e=t.numberOfChannels,n=t.length;let a=0;for(let s=0;s<e;s++){const e=t.getChannelData(s);for(let t=0;t<n;t++){const n=Math.abs(e[t]);n>a&&(a=n)}}if(0===a)return{buffer:t,dataUrl:await s(t)};const r=.99/a,o=new OfflineAudioContext(e,n,t.sampleRate),i=o.createBufferSource();i.buffer=t;const c=o.createGain();c.gain.value=r,i.connect(c),c.connect(o.destination),i.start(0);const l=await o.startRendering();return{buffer:l,dataUrl:await s(l)}}async function o(t,e=-60){const n=t.numberOfChannels,a=t.length,r=Math.pow(10,e/20);let o=a,i=0;for(let s=0;s<n;s++){const e=t.getChannelData(s);let n=0;for(;n<a&&Math.abs(e[n])<r;)n++;n<o&&(o=n);let c=a-1;for(;c>0&&Math.abs(e[c])<r;)c--;c>i&&(i=c)}const c=i-o+1;if(c<=0)return{buffer:t,dataUrl:await s(t)};const l=new OfflineAudioContext(n,c,t.sampleRate),u=l.createBufferSource();u.buffer=t,u.connect(l.destination),u.start(0,o/t.sampleRate);const f=await l.startRendering();return{buffer:f,dataUrl:await s(f)}}async function i(t){const e=t.numberOfChannels,n=t.length,a=new AudioBuffer({length:n,numberOfChannels:e,sampleRate:t.sampleRate});for(let r=0;r<e;r++){const e=t.getChannelData(r),o=a.getChannelData(r);for(let t=0;t<n;t++)o[t]=e[n-1-t]}return{buffer:a,dataUrl:await s(a)}}async function s(t){const e=function(t){const e=t.numberOfChannels,n=t.sampleRate,a=1,r=16,o=e*(r/8),i=t.length,s=i*o,l=44+s,u=new ArrayBuffer(l),f=new DataView(u);c(f,0,"RIFF"),f.setUint32(4,l-8,!0),c(f,8,"WAVE"),c(f,12,"fmt "),f.setUint32(16,16,!0),f.setUint16(20,a,!0),f.setUint16(22,e,!0),f.setUint32(24,n,!0),f.setUint32(28,n*o,!0),f.setUint16(32,o,!0),f.setUint16(34,r,!0),c(f,36,"data"),f.setUint32(40,s,!0);const h=44,m=[];for(let c=0;c<e;c++)m.push(t.getChannelData(c));let d=0;for(let c=0;c<i;c++)for(let t=0;t<e;t++){let e=m[t][c];e=Math.max(-1,Math.min(1,e)),f.setInt16(h+d,e<0?32768*e:32767*e,!0),d+=2}return u}(t),n=new Blob([e],{type:"audio/wav"});return new Promise((t,e)=>{const a=new FileReader;a.onload=()=>t(a.result),a.onerror=e,a.readAsDataURL(n)})}function c(t,e,n){for(let a=0;a<n.length;a++)t.setUint8(e+a,n.charCodeAt(a))}async function l(t,e){const n=t.sampleRate,a=Math.max(0,Math.min(e.trimStart,t.duration)),r=Math.max(a,Math.min(e.trimEnd,t.duration)),o=Math.max(1,Math.round((r-a)*n)),i=Math.round(a*n),c=new OfflineAudioContext(1,o,n),l=c.createBufferSource(),u=new AudioBuffer({numberOfChannels:1,length:t.length,sampleRate:n}),f=u.getChannelData(0);if(1===t.numberOfChannels)f.set(t.getChannelData(0));else{const e=t.getChannelData(0),n=t.getChannelData(1);for(let t=0;t<f.length;t++)f[t]=.5*(e[t]+n[t])}l.buffer=u,l.start(0,i/n,o/n);const h=c.createBiquadFilter();h.type="highpass",h.frequency.value=Math.max(20,e.loCutHz),h.Q.value=.707;const m=c.createBiquadFilter();m.type="lowpass",m.frequency.value=Math.min(n/2-1,e.hiCutHz),m.Q.value=.707;const d=c.createDynamicsCompressor();d.threshold.value=e.limiterEnabled?e.limiterThreshDb:0,d.knee.value=0,d.ratio.value=e.limiterEnabled?20:1,d.attack.value=.001,d.release.value=.01;const b=c.createGain();b.gain.value=e.limiterEnabled?Math.pow(10,e.limiterMakeupGain/100*20/20):1,l.connect(h),h.connect(m),m.connect(d),d.connect(b),b.connect(c.destination);return async function(t){const e=t.numberOfChannels,n=t.length,a=t.sampleRate;let r=0;for(let i=0;i<e;i++){const e=t.getChannelData(i);for(let t=0;t<n;t++){const n=Math.abs(e[t]);n>r&&(r=n)}}const o=new AudioBuffer({length:n,numberOfChannels:e,sampleRate:a});for(let i=0;i<e;i++){const e=t.getChannelData(i),a=o.getChannelData(i);for(let t=0;t<n;t++){let n=r>0?e[t]/r:e[t];n=Math.max(-1,Math.min(1,n));let o=Math.round(128*n);o=Math.max(-128,Math.min(127,o));const i=Math.pow(.5,8);a[t]=i*Math.floor(o/128/i)}}return{buffer:o,dataUrl:await s(o)}}(await c.startRendering())}const u=39062.5,f=26042,h={MPC60:{targetRate:4e4,bitDepth:12,quantize12bit:!0,antiAlias:!0,warmth:.3,useDither:!0,autoGain:!0,exactRates:!1,model:"MPC60"},MPC3000:{targetRate:44100,bitDepth:16,quantize12bit:!1,antiAlias:!0,warmth:.1,useDither:!1,autoGain:!1,exactRates:!1,model:"MPC3000"},SP1200:{targetRate:26040,bitDepth:12,quantize12bit:!0,antiAlias:!0,warmth:.4,useDither:!0,autoGain:!0,exactRates:!1,model:"SP1200"},MPC2000XL:{targetRate:44100,bitDepth:16,quantize12bit:!1,antiAlias:!0,warmth:.05,useDither:!1,autoGain:!1,exactRates:!1,model:"MPC2000XL"}},m={targetRate:4e4,bitDepth:12,quantize12bit:!0,antiAlias:!0,warmth:.2,useDither:!0,autoGain:!0,exactRates:!1,model:"MPC60"},d={MPC60:{input:15e3,output:15e3},MPC3000:{input:18e3,output:18e3},SP1200:{input:7500,output:7500},MPC2000XL:{input:2e4,output:2e4}};async function b(t,e){let n=t;const a=d[e.model]||d.MPC60;let r=e.targetRate;e.exactRates&&("MPC60"===e.model?r=u:"SP1200"===e.model&&(r=f)),e.antiAlias&&(n=await async function(t,e){const n=new OfflineAudioContext(t.numberOfChannels,t.length,t.sampleRate),a=n.createBufferSource();a.buffer=t;const r=n.createBiquadFilter();return r.type="lowpass",r.frequency.value=e,r.Q.value=.707,a.connect(r),r.connect(n.destination),a.start(0),await n.startRendering()}(n,a.input)),r!==t.sampleRate&&(n=function(t,e){const n=t.sampleRate/e,a=Math.floor(t.length/n),r=new OfflineAudioContext(t.numberOfChannels,a,e).createBuffer(t.numberOfChannels,a,e);for(let o=0;o<t.numberOfChannels;o++){const e=t.getChannelData(o),i=r.getChannelData(o);for(let t=0;t<a;t++){const a=Math.floor(t*n);i[t]=e[a]}}return r}(n,r)),e.useDither&&e.bitDepth<16&&(n=function(t,e){const n=.5*Math.pow(.5,e);for(let a=0;a<t.numberOfChannels;a++){const e=t.getChannelData(a);for(let t=0;t<e.length;t++){const a=(Math.random()-.5+(Math.random()-.5))*n;e[t]+=a}}return t}(n,e.bitDepth));const o=e.quantize12bit?12:e.bitDepth;o<16&&(n=function(t,e){if((e<1||e>16)&&(e=Math.max(1,Math.min(16,e))),e>=16)return t;const n=Math.pow(2,e);for(let a=0;a<t.numberOfChannels;a++){const e=t.getChannelData(a);for(let t=0;t<e.length;t++){let a=Math.floor(32768*e[t]);a=Math.max(-32768,Math.min(32767,a));const r=Math.floor(a*n/65536)*(65536/n);e[t]=r/32768}}return t}(n,o)),e.autoGain&&o<16&&(n=function(t,e){const n=1+.05*(16-e);let a=0;for(let o=0;o<t.numberOfChannels;o++){const e=t.getChannelData(o);for(let t=0;t<e.length;t++){const n=Math.abs(e[t]);n>a&&(a=n)}}const r=n*(a*n>.95?.95/(a*n):1);for(let o=0;o<t.numberOfChannels;o++){const e=t.getChannelData(o);for(let t=0;t<e.length;t++)e[t]*=r}return t}(n,o)),e.antiAlias&&(n=await async function(t,e){const n=new OfflineAudioContext(t.numberOfChannels,t.length,t.sampleRate),a=n.createBufferSource();a.buffer=t;const r=n.createBiquadFilter();return r.type="lowpass",r.frequency.value=e,r.Q.value=.707,a.connect(r),r.connect(n.destination),a.start(0),await n.startRendering()}(n,a.output)),e.warmth>0&&(n=function(t,e){if(e<=0)return t;const n=1+2*e;for(let a=0;a<t.numberOfChannels;a++){const e=t.getChannelData(a);for(let t=0;t<e.length;t++){const a=e[t]*n,r=a>=0?.95*Math.tanh(a)+.02*a:Math.tanh(.85*a);e[t]=Math.max(-1,Math.min(1,r))}}return t}(n,e.warmth));return{buffer:n,dataUrl:await s(n)}}export{m as D,h as M,i as a,s as b,o as c,r as d,a as e,n as f,e as g,t as h,l as i,b as m};
