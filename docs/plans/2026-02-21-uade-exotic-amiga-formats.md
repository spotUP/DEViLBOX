# UADE + Exotic Amiga Format Support

**Date:** 2026-02-21
**Status:** Complete (TypeScript implementation done; UADE WASM build pending)

## Progress Tracker

- [x] Phase 1: UADE-WASM Playback Layer
  - [x] 1.1 New types: `UADEConfig`, `'UADESynth'` in `SynthType`
  - [x] 1.2 `UADEEngine.ts` — Singleton AudioWorklet engine
  - [x] 1.3 `UADESynth.ts` — DevilboxSynth wrapper
  - [x] 1.4 `UADEParser.ts` — Catch-all import parser
  - [x] 1.5 Update `parseModuleToSong.ts` with UADE catch-all
  - [x] 1.6 Update `InstrumentFactory.ts` with UADESynth
  - [x] 1.7 `uade-wasm/` build scaffolding (C files, CMakeLists, build.sh)
  - [x] 1.8 `uade-wasm/src/shim_ipc.c` — In-memory IPC replacing socketpair
  - [x] 1.9 `uade-wasm/src/entry.c` — Merged entry point
  - [x] 1.10 `uade-wasm/generate_registry.py` — Player registry generator
  - [x] 1.11 `public/uade/UADE.worklet.js` — AudioWorklet processor
  - [ ] 1.12 Build UADE WASM and verify it compiles ← pending actual build

- [x] Phase 2: Full Editing — Sample-Based Formats
  - [x] 2.1 `OktalyzerParser.ts` + integration
  - [x] 2.2 `OktalyzerExporter.ts`
  - [x] 2.3 `MEDParser.ts` + integration
  - [x] 2.4 `MEDExporter.ts`
  - [x] 2.5 `DigiBoosterParser.ts` + integration
  - [x] 2.6 `DigiBoosterExporter.ts`

- [x] Phase 3: Full Editing — Future Composer 1.3/1.4
  - [x] 3.1 `FCParser.ts` (port of Furnace's fc.cpp)
  - [x] 3.2 `FCExporter.ts`

- [x] Verification
  - [x] TypeScript: `npx tsc --noEmit` → 0 errors ✓
  - [ ] UADE build produces `public/uade/UADE.{wasm,js}` ← pending
  - [ ] Tests pass: `npm test` ← not yet run

---

## Context

DEViLBOX already supports Furnace's console chip formats. This plan adds 130+ exotic Amiga music formats: AHX, JochenHippel, TFMX, Future Composer, FRED, SidMon, Hippel-7V, Oktalyzer, MED, DigiBooster, etc. These formats use real Amiga 68000 machine code (eagleplayer plugins) that can only be played by emulating the full Amiga hardware.

**Honest scope assessment:**
- **Playback** for all 130+ formats: achievable via UADE-WASM (emulates Amiga 68000 + Paula chip, runs real eagleplayer binaries)
- **Full editing** for sample-based formats (Oktalyzer, OctaMED, DigiBooster): achievable — well-documented binary formats, map cleanly to `TrackerSong`
- **Full editing** for synthesis formats (Future Composer 1.3/1.4): achievable — Furnace already has a reference FC parser in `src/engine/loader/fc.cpp` we can port
- **Full editing** for opaque formats (JochenHippel, TFMX, SIDMon, AHX-beyond-HVL): not realistic — formats are poorly documented and tightly coupled to Amiga hardware quirks

---

## Architecture

```
Import pipeline:
  File → detectFormat() → {
    OKT  → OktalyzerParser   → TrackerSong (sample instruments)
    MED  → MEDParser         → TrackerSong (sample instruments)
    DIGI → DigiBoosterParser → TrackerSong (sample instruments)
    FC   → FCParser          → TrackerSong (FurnaceAMIGA instruments)
    *    → UADEParser        → TrackerSong (UADEConfig, playback-only)
  }

UADESynth (playback-only):
  UADEConfig (stores original file bytes)
  → UADEEngine (singleton, AudioWorklet)
  → UADE.worklet.js
  → UADE.wasm (merged uadecore + libuade, 175 eagleplayers embedded)
  → Paula emulation → PCM audio → output GainNode
```

---

## Phase 1 — UADE-WASM Playback Layer

### The Core Challenge: fork() + socketpair()

UADE's normal architecture splits into two processes communicating via `socketpair()`:
- `libuade` (frontend): controls playback, sends `uade_ipc` commands
- `uadecore` (68k emulator + chip emulation): receives commands, outputs PCM

The spawn is in `unixsupport.c::uade_arch_spawn()` (~line 219). Emscripten cannot compile `fork()`.

**Solution:** Merge both sides into a single WASM module. Replace `socketpair()` IPC with an in-memory ring buffer pair.

### New directory: `uade-wasm/`

```
uade-wasm/
  CMakeLists.txt             (Emscripten build)
  src/
    entry.c                  (merged main: init uadecore + libuade in-process)
    shim_ipc.c               (replaces unixsupport.c: in-memory ring buffers)
    player_registry.c        (autogenerated: 175 eagleplayer binaries as C arrays)
    player_registry.h
    score_binary.c           (embedded score stub)
  generate_registry.py       (reads players/ dir, generates player_registry.c)
  build.sh                   (emcc invocation)
```

**Key UADE source files to include in build** (from `/Users/spot/Code/DEViLBOX/Reference Code/uade-3.05/`):
- `src/newcpu.c` — 68000 CPU emulator
- `src/custom.c` — Amiga custom chip emulation (DMA, interrupts)
- `src/audio.c` — Paula chip (4-channel DMA audio)
- `src/memory.c` — Amiga memory map
- `src/uadestate.c` — public API (`uade_play_file`, `uade_read`, `uade_stop`)
- `src/frontends/common/uadeconf.c` — config parsing
- **Exclude**: `src/frontends/common/unixsupport.c` (replaced by `shim_ipc.c`)

**`shim_ipc.c`** — Replace fork/socket with in-memory ring buffers:
```c
static uint8_t cmd_buf[65536], rsp_buf[65536];
static volatile int cmd_head, cmd_tail, rsp_head, rsp_tail;

void uade_arch_spawn(struct uade_ipc *ipc, ...) {
  ipc->in_fd  = CMD_FD_MAGIC;
  ipc->out_fd = RSP_FD_MAGIC;
  uadecore_init();  // called inline, no fork
}
ssize_t uade_shim_read(int fd, void *buf, size_t n);
ssize_t uade_shim_write(int fd, const void *buf, size_t n);
```

**`player_registry.c`** (autogenerated by `generate_registry.py`):
```c
static const uint8_t player_JochenHippel_data[] = { 0x00, 0x00, ... };
static const uint8_t player_TFMX_data[]         = { ... };
// ... all 175 players

const UADEPlayer uade_players[] = {
  { "JochenHippel",  player_JochenHippel_data,  sizeof(player_JochenHippel_data) },
  { "TFMX-14",       player_TFMX_data,          sizeof(player_TFMX_data) },
};
```

**Exported WASM API** (via `EMSCRIPTEN_KEEPALIVE`):
```c
int  uade_wasm_init(void);
int  uade_wasm_load(const uint8_t *data, size_t len, const char *filename_hint);
int  uade_wasm_render(float *out_l, float *out_r, int frames);
void uade_wasm_stop(void);
int  uade_wasm_get_subsong_count(void);
void uade_wasm_set_subsong(int subsong);
```

### New TypeScript/JS files

**`public/uade/UADE.worklet.js`** — AudioWorklet processor:
- Loads `UADE.wasm` inside worklet global scope
- `process()`: calls `uade_wasm_render(leftBuf, rightBuf, 128)`, fills AudioBuffer
- Handles `load`, `stop`, `setSubsong` messages from main thread

**`src/engine/uade/UADEEngine.ts`** — Singleton (pattern: `HivelyEngine`):
```typescript
export class UADEEngine {
  static getInstance(): UADEEngine;
  readonly output: GainNode;
  async ready(): Promise<void>;
  async load(data: ArrayBuffer, filenameHint: string): Promise<UADEMetadata>;
  play(): void;
  stop(): void;
  setSubsong(index: number): void;
}
```

**`src/engine/uade/UADESynth.ts`** — `DevilboxSynth` impl (pattern: `HivelySynth`):
- `triggerAttack()` → `engine.play()`
- `triggerRelease()` → `engine.stop()`
- `setInstrument(config: UADEConfig)` → `engine.load(config.fileData, config.filename)`

**`src/lib/import/formats/UADEParser.ts`** — Catch-all parser:
- Returns `TrackerSong` with single instrument of type `'uade'`
- Single empty pattern (no editable cells) — playback-only
- `UADEConfig` stored in instrument config

### New types (`src/types/instrument.ts`)

```typescript
export interface UADEConfig {
  type: 'uade';
  filename: string;
  fileData: ArrayBuffer;
  subsongCount: number;
  currentSubsong: number;
  metadata: {
    player: string;
    formatName: string;
    minSubsong: number;
    maxSubsong: number;
  };
}
```

Add `'uade'` to `SynthType` union. Add UADE as final catch-all in `src/lib/import/parseModuleToSong.ts`.

---

## Phase 2 — Full Editing: Sample-Based Formats

### 2a. Oktalyzer (`.okt`)

**`src/lib/import/formats/OktalyzerParser.ts`** — IFF-style chunks:
- `CMOD` (channel modes), `SAMP` (sample headers), `SPEE` (speed), `SLEN/PLEN` (lengths)
- `PATT` (sequence), `PATn` (8-channel pattern data: 4 bytes/cell: sample, command, period, data)
- `SBOD` (sample PCM data)
- Output: `TrackerSong` with 8 channels + `SampleInstrument` per sample

**`src/lib/export/OktalyzerExporter.ts`**

### 2b. MED / OctaMED (`.med`, `.mmd0`, `.mmd1`, `.mmd2`, `.mmd3`)

**`src/lib/import/formats/MEDParser.ts`** — OpenMED spec:
- Handle MMD0 (4-8 channels) and MMD1/2 (up to 64 channels)
- `MMD0Block`/`MMD1Block` pattern data, `InstrHdr` sample instruments
- Reference: `/Users/spot/Code/DEViLBOX/Reference Code/furnace-master/src/engine/loader/med.cpp`

**`src/lib/export/MEDExporter.ts`**

### 2c. DigiBooster (`.digi`)

**`src/lib/import/formats/DigiBoosterParser.ts`** — MOD-like:
- 8-channel, `DBMX` header magic, optional ADPCM sample compression
- 128 samples, up to 127 patterns, 128-position song order

**`src/lib/export/DigiBoosterExporter.ts`**

No new UI needed — existing TrackerView/PatternEditor/InstrumentEditor work with these.

---

## Phase 3 — Full Editing: Future Composer 1.3 / 1.4

Future Composer uses synthesis patterns (waveform/envelope/arpeggio sequences) that map directly to Furnace's AMIGA chip emulation, already supported by DEViLBOX.

**`src/lib/import/formats/FCParser.ts`** — TypeScript port of:
`/Users/spot/Code/DEViLBOX/Reference Code/furnace-master/src/engine/loader/fc.cpp` (~600 lines)
- Detect FC 1.3 (magic `FC13`) and FC 1.4 (magic `FC14`)
- Parse instrument definitions (waveform, envelope, arpeggio, vibrato sequences)
- Parse pattern data + sequence table
- Output: `TrackerSong` with `FurnaceAMIGA` instruments

**`src/lib/export/FCExporter.ts`** — `TrackerSong` → FC14 binary

---

## Critical Files to Modify

| File | Change |
|------|--------|
| `src/lib/import/parseModuleToSong.ts` | Add OKT/MED/DIGI/FC parsers; UADE as catch-all |
| `src/lib/import/detectFormat.ts` | Add format detection for new formats |
| `src/types/instrument.ts` | Add `UADEConfig` interface, add `'uade'` to `SynthType` |
| `src/engine/InstrumentFactory.ts` | Add `UADESynth` creation for `'uade'` type |
| `src/components/dialogs/ImportDialog.tsx` | Show supported format list; UADE = playback-only badge |

## New Files

| File | Purpose |
|------|---------|
| `uade-wasm/src/entry.c` | Merged UADE entry point (no fork) |
| `uade-wasm/src/shim_ipc.c` | In-memory ring buffer replacing socketpair |
| `uade-wasm/generate_registry.py` | Autogenerate player_registry.c from `players/` dir |
| `uade-wasm/build.sh` | Emscripten build script |
| `public/uade/UADE.worklet.js` | AudioWorklet processor |
| `src/engine/uade/UADEEngine.ts` | Singleton engine |
| `src/engine/uade/UADESynth.ts` | DevilboxSynth wrapper |
| `src/lib/import/formats/UADEParser.ts` | Catch-all parser → playback-only TrackerSong |
| `src/lib/import/formats/OktalyzerParser.ts` | Full Oktalyzer parser |
| `src/lib/export/OktalyzerExporter.ts` | Full Oktalyzer exporter |
| `src/lib/import/formats/MEDParser.ts` | OctaMED/MED parser |
| `src/lib/export/MEDExporter.ts` | MED exporter |
| `src/lib/import/formats/DigiBoosterParser.ts` | DigiBooster parser |
| `src/lib/export/DigiBoosterExporter.ts` | DigiBooster exporter |
| `src/lib/import/formats/FCParser.ts` | Future Composer 1.3/1.4 parser |
| `src/lib/export/FCExporter.ts` | Future Composer 1.4 exporter |

---

## Notes

- `AHX`/`HVL` formats are already handled by `HivelySynth` — detect BEFORE the UADE catch-all in `parseModuleToSong.ts`
- UADE WASM binary will be ~2-4 MB. Consider lazy-loading: only load when a UADE-format file is first imported
- Some eagleplayers require Amiga ROM (`kick.rom`) which cannot be distributed — fail gracefully with a "ROM required" error
- Furnace FC parser reference: `/Users/spot/Code/DEViLBOX/Reference Code/furnace-master/src/engine/loader/fc.cpp`
- Furnace MED parser reference: `/Users/spot/Code/DEViLBOX/Reference Code/furnace-master/src/engine/loader/med.cpp`
- UADE source: `/Users/spot/Code/DEViLBOX/Reference Code/uade-3.05/`
