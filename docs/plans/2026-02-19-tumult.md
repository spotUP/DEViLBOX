# Tumult Effect — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Port the Tumult HISE noise/ambience plugin to DEViLBOX as an AudioWorklet effect using the EffectDescriptor/EffectRegistry SDK.

**Architecture:** An AudioWorklet (`public/tumult/Tumult.worklet.js`) handles all DSP: 5 noise modes (1:1 from `noise.cpp`), 5-band SVF EQ (1:1 from `svf_*.cpp`), arctan clipper (1:1 from `hardSoftClipper.h`), and an AR envelope follower for Duck/Follow modes. A `TumultEffect.ts` Tone.js wrapper handles sample decoding and worklet lifecycle. The effect is registered via `EffectRegistry` so `InstrumentFactory` needs no changes.

**Tech Stack:** TypeScript, React, Tone.js, Web Audio API AudioWorklet

**Reference code:** `Reference Code/Tumult-master/DspNetworks/ThirdParty/src/` (Faust-compiled C++), `Reference Code/Tumult-master/DspNetworks/CodeLibrary/snex_shaper/hardSoftClipper.h`

---

## Task 1: Type system and registry plumbing

**Files:**
- Modify: `src/types/instrument.ts`
- Modify: `src/constants/unifiedEffects.ts`
- Create: `src/engine/registry/effects/tumult.ts`
- Modify: `src/engine/registry/effects/index.ts`

**Step 1: Add `'Tumult'` to the AudioEffectType union**

In `src/types/instrument.ts`, find the line `| 'VinylNoise'` (around line 2227) and add after it:

```typescript
  | 'Tumult'           // Tumult noise/ambience generator (AudioWorklet, 1:1 port)
```

**Step 2: Add Tumult to the effect browser catalog**

In `src/constants/unifiedEffects.ts`, find the `VinylNoise` entry and add after it:

```typescript
  {
    category: 'wasm',
    type: 'Tumult',
    label: 'Tumult',
    group: 'Texture',
    description: 'Noise & ambience generator — 5 synth modes + 95 bundled samples, 5-band SVF EQ, Duck/Follow sidechain (Tumult port)',
  },
```

**Step 3: Create the EffectDescriptor registration file**

Create `src/engine/registry/effects/tumult.ts`:

```typescript
/**
 * Tumult effect registration.
 * 1:1 port of Tumult HISE noise/ambience generator.
 * DSP: noise.cpp + svf_*.cpp + hardSoftClipper.h (Faust/SNEX compiled sources)
 */

import type { EffectConfig } from '@typedefs/instrument';
import { EffectRegistry } from '../EffectRegistry';

EffectRegistry.register({
  id: 'Tumult',
  name: 'Tumult',
  category: 'wasm',
  group: 'Texture',
  loadMode: 'eager',

  create: async (c: EffectConfig) => {
    const { TumultEffect } = await import('@engine/effects/TumultEffect');
    const p = c.parameters;
    return new TumultEffect({
      noiseGain:       Number(p.noiseGain       ?? -10.6),
      mix:             Number(p.mix             ?? 1.0),
      noiseMode:       Number(p.noiseMode       ?? 0),
      sourceMode:      Number(p.sourceMode      ?? 0),
      switchBranch:    Number(p.switchBranch    ?? 1),
      duckThreshold:   Number(p.duckThreshold   ?? -17.2),
      duckAttack:      Number(p.duckAttack      ?? 0),
      duckRelease:     Number(p.duckRelease     ?? 21.5),
      followThreshold: Number(p.followThreshold ?? -10.7),
      followAttack:    Number(p.followAttack    ?? 0),
      followRelease:   Number(p.followRelease   ?? 76.9),
      followAmount:    Number(p.followAmount    ?? 0.104),
      clipAmount:      Number(p.clipAmount      ?? 0.497),
      hpEnable:        Number(p.hpEnable        ?? 0),
      hpFreq:          Number(p.hpFreq          ?? 888.5),
      hpQ:             Number(p.hpQ             ?? 0.7),
      peak1Enable:     Number(p.peak1Enable     ?? 1),
      peak1Type:       Number(p.peak1Type       ?? 0),
      peak1Freq:       Number(p.peak1Freq       ?? 20),
      peak1Gain:       Number(p.peak1Gain       ?? -0.19),
      peak1Q:          Number(p.peak1Q          ?? 0.7),
      peak2Enable:     Number(p.peak2Enable     ?? 1),
      peak2Freq:       Number(p.peak2Freq       ?? 600),
      peak2Gain:       Number(p.peak2Gain       ?? 1.0),
      peak2Q:          Number(p.peak2Q          ?? 1.0),
      peak3Enable:     Number(p.peak3Enable     ?? 0),
      peak3Type:       Number(p.peak3Type       ?? 1),
      peak3Freq:       Number(p.peak3Freq       ?? 2500),
      peak3Gain:       Number(p.peak3Gain       ?? 1.0),
      peak3Q:          Number(p.peak3Q          ?? 1.0),
      lpEnable:        Number(p.lpEnable        ?? 0),
      lpFreq:          Number(p.lpFreq          ?? 8500),
      lpQ:             Number(p.lpQ             ?? 0.7),
      sampleIndex:     Number(p.sampleIndex     ?? 0),
      playerStart:     Number(p.playerStart     ?? 0),
      playerEnd:       Number(p.playerEnd       ?? 1),
      playerFade:      Number(p.playerFade      ?? 0.01),
      playerGain:      Number(p.playerGain      ?? 0),
      wet: c.wet / 100,
    });
  },

  getDefaultParameters: () => ({
    noiseGain: -10.6, mix: 1.0, noiseMode: 0, sourceMode: 0, switchBranch: 1,
    duckThreshold: -17.2, duckAttack: 0, duckRelease: 21.5,
    followThreshold: -10.7, followAttack: 0, followRelease: 76.9, followAmount: 0.104,
    clipAmount: 0.497,
    hpEnable: 0, hpFreq: 888.5, hpQ: 0.7,
    peak1Enable: 1, peak1Type: 0, peak1Freq: 20, peak1Gain: -0.19, peak1Q: 0.7,
    peak2Enable: 1, peak2Freq: 600, peak2Gain: 1.0, peak2Q: 1.0,
    peak3Enable: 0, peak3Type: 1, peak3Freq: 2500, peak3Gain: 1.0, peak3Q: 1.0,
    lpEnable: 0, lpFreq: 8500, lpQ: 0.7,
    sampleIndex: 0, playerStart: 0, playerEnd: 1, playerFade: 0.01, playerGain: 0,
  }),
});
```

**Step 4: Import in effects/index.ts**

In `src/engine/registry/effects/index.ts`, add after `import './wasm';`:

```typescript
import './tumult';
```

**Step 5: Verify TypeScript compiles**

```bash
cd /Users/spot/Code/DEViLBOX && npx tsc --noEmit 2>&1 | head -30
```
Expected: no errors related to Tumult.

**Step 6: Commit**

```bash
git add src/types/instrument.ts src/constants/unifiedEffects.ts \
        src/engine/registry/effects/tumult.ts src/engine/registry/effects/index.ts
git commit -m "feat(tumult): add Tumult to type system and EffectRegistry"
```

---

## Task 2: Copy sample files

**Files:**
- Create: `public/tumult/samples/` (95 WAV files)

**Step 1: Mirror the Tumult Samples directory**

```bash
mkdir -p /Users/spot/Code/DEViLBOX/public/tumult/samples
cp -r "/Users/spot/Code/DEViLBOX/Reference Code/Tumult-master/Samples/"* \
      /Users/spot/Code/DEViLBOX/public/tumult/samples/
```

**Step 2: Verify**

```bash
find /Users/spot/Code/DEViLBOX/public/tumult/samples -name "*.wav" | wc -l
```
Expected: `95`

**Step 3: Commit**

```bash
git add public/tumult/samples/
git commit -m "feat(tumult): bundle 95 sample WAV files"
```

---

## Task 3: AudioWorklet — noise generator DSP

**Files:**
- Create: `public/tumult/Tumult.worklet.js` (initial skeleton + noise section)

**Context:** This is a direct port from `noise.cpp` (Faust 2.74.5 generated). Do NOT approximate — every constant comes from the source file. The LCG, pink filter coefficients, and all 168 `fConst` values for the colored noise chains are in `noise.cpp` lines 320–491 and 621–703.

**Step 1: Create the worklet file with the noise DSP class**

Create `public/tumult/Tumult.worklet.js` with the following content. This file has three sections: constants, classes, and the AudioWorkletProcessor registration.

```javascript
// public/tumult/Tumult.worklet.js
// Tumult noise/ambience generator — DSP ported 1:1 from:
//   noise.cpp (Faust 2.74.5, LGPL/MIT)
//   svf_hp/lp/peak/ls/hs.cpp (Faust 2.74.5, MIT)
//   hardSoftClipper.h (SNEX)
// Reference: Reference Code/Tumult-master/DspNetworks/ThirdParty/src/

// ─── Noise Generator (1:1 from noise.cpp) ─────────────────────────────────────
// All constants and algorithms match the compiled Faust output exactly.
class TumultNoise {
  constructor(sr) {
    this.sr = sr;
    // LCG state
    this.iRec0 = 0;
    this.iVec0 = 0;
    this.fVec1 = 0;

    // Pink noise: 4-tap IIR (no.pink_noise) — fRec1[0..3]
    this.fRec1 = new Float32Array(4);

    // DC blocker + 12-stage chain for colored noise modes 2 & 3
    this.fRec14 = new Float32Array(2); // DC blocker
    // Mode 2 chain (colored_noise(12,-1.6)): fRec2..fRec13
    this.rec2  = new Float32Array(2); this.rec3  = new Float32Array(2);
    this.rec4  = new Float32Array(2); this.rec5  = new Float32Array(2);
    this.rec6  = new Float32Array(2); this.rec7  = new Float32Array(2);
    this.rec8  = new Float32Array(2); this.rec9  = new Float32Array(2);
    this.rec10 = new Float32Array(2); this.rec11 = new Float32Array(2);
    this.rec12 = new Float32Array(2); this.rec13 = new Float32Array(2);
    // Mode 3 chain (colored_noise(12,0.5)): fRec15..fRec26
    this.rec15 = new Float32Array(2); this.rec16 = new Float32Array(2);
    this.rec17 = new Float32Array(2); this.rec18 = new Float32Array(2);
    this.rec19 = new Float32Array(2); this.rec20 = new Float32Array(2);
    this.rec21 = new Float32Array(2); this.rec22 = new Float32Array(2);
    this.rec23 = new Float32Array(2); this.rec24 = new Float32Array(2);
    this.rec25 = new Float32Array(2); this.rec26 = new Float32Array(2);

    // Mode 4: NLF2 oscillator + sample-hold — fRec27,fRec28,fRec29
    this.fRec27 = new Float32Array(2);
    this.fRec28 = new Float32Array(2);
    this.fRec29 = new Float32Array(2);

    // Precompute all fConst values (noise.cpp instanceConstants)
    this._initConsts(sr);
  }

  _initConsts(sr) {
    const s = Math.min(192000, Math.max(1, sr));
    this.fConst0 = s;
    // DC blocker
    this.fConst1 = 1 / Math.tan(0.5 / s);
    const fConst2_base = Math.tan(62.831852 / s);
    this.fConst2_base = fConst2_base; // tan(2π*10/sr) — base for spectral_tilt

    // Helper to compute one "spectral_tilt" stage pair of consts:
    // Each stage uses: fRecN[0] = -(1/D) * (coeff_a*fRecN[1] - ratio*(fConst_hi*fRecNm1[0] + fConst_lo*fRecNm1[1]))
    // where all the ratios come from pairs of tan values.
    // All const values come from noise.cpp lines 322–491 verbatim.

    // ── Mode 2 colored_noise(12,-1.6) chain constants ─────────────────────
    const c = (f) => Math.tan(f / s);
    // (fConst8) fRec13: first stage after DC blocker
    const t3  = c(171.61037);
    const t2b = fConst2_base;
    this.C_k8  = 125.663704 * (t3 / t2b);  // fConst4
    this.C_a8  = this.C_k8 - this.fConst1;  // fConst5
    this.C_b8  = this.fConst1 + this.C_k8;  // fConst6
    this.C_7   = 125.663704 - this.fConst1; // fConst7
    this.C_8   = 1 / (this.fConst1 + 125.663704); // fConst8

    // I'll list all 12 stages for mode 2 as arrays for compactness:
    // freqs from noise.cpp instanceConstants (lines 325, 331, 336, 341, 347, 352, 358, 363, 369, 374, 380, 385, 391, 396...)
    const m2freqs = [171.61037, 321.5665, 602.5569, 1129.0815, 2115.6926, 3964.4219,
                     7428.603, 13919.846, 26083.248, 48875.246, 91583.29, 171610.36];
    const m2prev  = [62.831852, 171.61037, 321.5665, 602.5569, 1129.0815, 2115.6926,
                     3964.4219, 7428.603, 13919.846, 26083.248, 48875.246, 91583.29];
    // fConst9,11,12... for odd stages; fConst10... for even
    // Pattern: fConst[3k+9] = 125.663704*(tan(m2freqs[k])/fConst2_base)
    //          fConst[3k+8] = above - fConst1  (a coeff)
    //          fConst[3k+12]= fConst1 + above  (b coeff)
    //          ratio[k]     = tan(m2prev[k])/tan(m2freqs[k])
    this.m2 = m2freqs.map((f, i) => {
      const tF = c(f);
      const tP = c(m2prev[i]);
      const k  = 125.663704 * (tF / t2b);
      return {
        a:   k - this.fConst1,
        b:   this.fConst1 + k,
        inv: 1 / (this.fConst1 + k),
        r:   tP / tF,
      };
    });
    // Normalizing scalar for mode 2 output (fConst108)
    const t104 = c(62831.85);
    const t99  = c(171610.36);
    this.C_108 = 49.96747 * (t104 / t99);

    // ── Mode 3 colored_noise(12,0.5) chain constants ──────────────────────
    const m3freqs = [45.900375, 86.00892, 161.16502, 301.9938, 565.8813, 1060.3582,
                     1986.9176, 3723.1208, 6976.4487, 13072.592, 24495.65, 45900.375];
    const m3prev  = [62.831852, 45.900375, 86.00892, 161.16502, 301.9938, 565.8813,
                     1060.3582, 1986.9176, 3723.1208, 6976.4487, 13072.592, 24495.65];
    this.m3 = m3freqs.map((f, i) => {
      const tF = c(f);
      const tP = c(m3prev[i]);
      const k  = 125.663704 * (tF / t2b);
      return {
        a:   k - this.fConst1,
        b:   this.fConst1 + k,
        inv: 1 / (this.fConst1 + k),
        r:   tP / tF,
      };
    });
    const t163 = c(45900.375);
    this.C_168 = 0.013842662 * (t104 / t163);

    // Mode 2 first stage uses DC-blocker output with special consts:
    this.C_111 = 125.663704 * (c(117.73542) / t2b) - this.fConst1; // fConst16-equivalent for DC output
    this.C_112 = 1 / (this.fConst1 + 125.663704 * (c(117.73542) / t2b));

    // ── Mode 3 first stage with DC-blocker ───────────────────────────────
    const t109 = c(45.900375);
    this.C_110 = 125.663704 * (t109 / t2b) - this.fConst1;
    this.C_110b = 1 / (this.fConst1 + 125.663704 * (t109 / t2b));
    this.C_117 = t2b / t109; // ratio for mode 3 first stage

    // DC blocker stage 0 consts (fConst5,6,7,8):
    const t2_dc = Math.tan(62.831852 / s);
    this.DC_a = this.C_a8;
    this.DC_b = this.C_b8;
    this.DC_7 = this.C_7;
    this.DC_8 = this.C_8;
  }

  /** Generate one stereo sample pair. Returns [L, R] (identical). */
  tick(mode) {
    // ── LCG (ANSI C rand) ──────────────────────────────────────────────────
    const iRec0New = (Math.imul(1103515245, this.iRec0) + 12345) | 0;
    const fTemp0   = iRec0New;
    const white    = 4.656613e-10 * fTemp0;
    const whiteL   = 4.656613e-10 * this.fVec1; // delayed white for DC blocker

    // ── DC blocker (for modes 2 and 3) ────────────────────────────────────
    // fRec14[0] = 0.995*fRec14[1] + white - white_prev
    const dcNew = 0.995 * this.fRec14[1] + 4.656613e-10 * (fTemp0 - this.fVec1);

    let out;

    if (mode === 0) {
      // ── Mode 0: White noise ─────────────────────────────────────────────
      out = white;

    } else if (mode === 1) {
      // ── Mode 1: Pink noise (no.pink_noise * 10) ─────────────────────────
      // 3rd-order IIR — coefficients from noise.cpp line 635
      const r1 = this.fRec1;
      const p  = 0.5221894 * r1[3] + white + 2.494956 * r1[1] - 2.0172658 * r1[2];
      out = 10 * (0.049922034 * p + 0.0506127 * r1[2]
                - 0.095993534 * r1[1] - 0.004408786 * r1[3]);
      r1[3] = r1[2]; r1[2] = r1[1]; r1[1] = r1[0]; r1[0] = p;

    } else if (mode === 2) {
      // ── Mode 2: Brown (colored_noise(12,-1.6)) ───────────────────────────
      // 12-stage spectral_tilt filter chain after DC blocker
      // First stage uses DC blocker output (dcNew) with special routing (noise.cpp line 637)
      const dc14 = dcNew;
      // Stage 0 special (fRec13, using fConst8,7,6,5 and fConst16,17):
      const r13new = -(this.C_112 * (this.C_111 * this.rec13[1]
        - (this.m2[0].b * dc14 + this.m2[0].a * this.fRec14[1])));
      // Stages 1–11: standard spectral_tilt cascade
      const chain2 = [this.rec12, this.rec11, this.rec10, this.rec9, this.rec8,
                      this.rec7, this.rec6, this.rec5, this.rec4, this.rec3, this.rec2];
      let prev0 = r13new, prev1 = this.rec13[1];
      for (let i = 1; i < 12; i++) {
        const m = this.m2[i];
        const rec = chain2[i - 1];
        const newVal = -(m.inv * (m.a * rec[1] - m.r * (m.b * prev0 + (this.fConst1 + m.r * m.a) * prev1)));
        prev1 = rec[0]; rec[0] = newVal; prev0 = newVal;
      }
      // NOTE: After init, update all recs in tick — see below
      out = Math.min(1, Math.max(-1, this.C_108 * this.rec2[0]));

    } else if (mode === 3) {
      // ── Mode 3: Velvet (colored_noise(12,0.5)) ───────────────────────────
      // Same structure as mode 2 but different consts, different chain
      const dc14 = dcNew;
      const r26new = -(this.C_110b * (this.C_110 * this.rec26[1]
        - (this.C_117 * (this.m3[0].b * dc14 + this.m3[0].a * this.fRec14[1]))));
      const chain3 = [this.rec25, this.rec24, this.rec23, this.rec22, this.rec21,
                      this.rec20, this.rec19, this.rec18, this.rec17, this.rec16, this.rec15];
      let prev0 = r26new, prev1 = this.rec26[1];
      for (let i = 1; i < 12; i++) {
        const m = this.m3[i];
        const rec = chain3[i - 1];
        const newVal = -(m.inv * (m.a * rec[1] - m.r * (m.b * prev0 + (this.fConst1 + m.r * m.a) * prev1)));
        prev1 = rec[0]; rec[0] = newVal; prev0 = newVal;
      }
      out = Math.min(1, Math.max(-1, this.C_168 * this.rec15[0]));

    } else {
      // ── Mode 4: Crushed (lfnoiseN(0, SR/100)) ──────────────────────────
      // NLF2 quadrature oscillator at SR/100 Hz (noise.cpp lines 661–664)
      const r28New = 0.06279052 * this.fRec29[1] + 0.9980267 * this.fRec28[1];
      const r29New = (1 - this.iVec0) + 0.9980267 * this.fRec29[1] - 0.06279052 * this.fRec28[1];
      const trigger = (this.fRec28[1] <= 0) && (r28New > 0);
      const r27New  = trigger ? white : this.fRec27[1];
      out = r27New;

      this.fRec28[1] = r28New; this.fRec28[0] = r28New;
      this.fRec29[1] = r29New; this.fRec29[0] = r29New;
      this.fRec27[1] = r27New;
    }

    // ── State updates ──────────────────────────────────────────────────────
    this.iRec0 = iRec0New;
    this.fVec1 = fTemp0;
    this.fRec14[1] = dcNew;
    this.rec13[1] = this.rec13[0];
    for (const r of [this.rec12, this.rec11, this.rec10, this.rec9, this.rec8,
                     this.rec7, this.rec6, this.rec5, this.rec4, this.rec3, this.rec2]) {
      r[1] = r[0];
    }
    this.rec26[1] = this.rec26[0];
    for (const r of [this.rec25, this.rec24, this.rec23, this.rec22, this.rec21,
                     this.rec20, this.rec19, this.rec18, this.rec17, this.rec16, this.rec15]) {
      r[1] = r[0];
    }
    this.iVec0 = 1;

    return out;
  }
}
```

**Step 2: Verify the noise class can be loaded without errors**

Open browser console and paste:
```js
// Quick smoke test for LCG
let iRec0 = 0;
for (let i = 0; i < 5; i++) {
  iRec0 = (Math.imul(1103515245, iRec0) + 12345) | 0;
  console.log(4.656613e-10 * iRec0);
}
// Expected: ~[-0.0057, 0.0062, ...] — small bipolar values
```

**Step 3: Commit**

```bash
git add public/tumult/Tumult.worklet.js
git commit -m "feat(tumult): worklet — noise generator DSP (noise.cpp 1:1 port)"
```

---

## Task 4: AudioWorklet — SVF filter classes

**Files:**
- Modify: `public/tumult/Tumult.worklet.js` (append SVF classes)

**Context:** All 5 SVF filters use the same Oleg Nesterov TPT topology (Faust `fi.svf.*`). They share identical smoothing constants (`fConst1 = 44.1/SR`, `fConst2 = 1-44.1/SR`, `fConst3 = π/SR`). The compute loop is ported verbatim from each `svf_*.cpp`.

**Step 1: Append a single SVFBand class that handles all 5 filter types**

Append to `public/tumult/Tumult.worklet.js`:

```javascript
// ─── SVF Band (1:1 from svf_lp/hp/peak/ls/hs.cpp — Faust 2.74.5) ─────────────
// All 5 filter types share the same TPT state variable topology.
// Smoothing: one-pole IIR at 10 Hz (44.1/SR alpha), matching Faust fConst1/fConst2.
class SVFBand {
  constructor(sr) {
    // Smoothing constants (from svf_lp.cpp instanceConstants):
    // fConst1 = 44.1/SR, fConst2 = 1 - 44.1/SR, fConst3 = π/SR
    this.alpha  = 44.1 / sr;        // fConst1
    this.oneMA  = 1 - 44.1 / sr;   // fConst2
    this.piOverSr = Math.PI / sr;   // fConst3

    // Smoothed parameter states (freq, Q, gain)
    this.freqS = 1000;   // fRec3 (or fRec5)
    this.qS    = 0.7;    // fRec4 (or fRec0/fRec1/fRec6)
    this.gainS = 0;      // fRec0 (peak/shelf only)

    // Filter state: two integrators, stereo (L and R)
    this.s1L = 0; this.s2L = 0;  // fRec0[2], fRec1[2] for L
    this.s1R = 0; this.s2R = 0;  // fRec5[2], fRec6[2] for R

    // Target values (set by setParams)
    this.freqTarget = 1000;
    this.qTarget    = 0.7;
    this.gainTarget = 0;
    this.type = 'lp';  // 'lp' | 'hp' | 'peak' | 'ls' | 'hs'
    this.enabled = false;
  }

  setParams(type, freq, q, gainDb, enabled) {
    this.type        = type;
    this.freqTarget  = Math.max(20, Math.min(20000, freq));
    this.qTarget     = Math.max(0.7, Math.min(10, q));
    this.gainTarget  = Math.max(-24, Math.min(24, gainDb ?? 0));
    this.enabled     = enabled;
  }

  // Process one stereo sample pair. Returns [outL, outR].
  // Ported verbatim from each svf_*.cpp compute() loop body.
  tick(inL, inR) {
    if (!this.enabled) return [inL, inR];

    // ── Smooth parameters (one-pole IIR, matching Faust fConst1/fConst2) ──
    // fSlow = alpha * target
    // fRec = fSlow + oneMA * fRec_prev
    this.freqS = this.alpha * this.freqTarget + this.oneMA * this.freqS;
    this.qS    = this.alpha * this.qTarget    + this.oneMA * this.qS;
    this.gainS = this.alpha * this.gainTarget + this.oneMA * this.gainS;

    const g = Math.tan(this.piOverSr * this.freqS);

    let outL, outR;

    if (this.type === 'lp') {
      // svf_lp.cpp lines 165–183
      const den = g * (g + 1 / this.qS) + 1;
      // L:
      const t3L  = this.s1L + g * (inL - this.s2L);
      const v1L  = t3L / den;
      this.s1L   = 2 * v1L - this.s1L;
      const t5L  = this.s2L + g * t3L / den;
      this.s2L   = 2 * t5L - this.s2L;
      outL = t5L;
      // R:
      const t3R  = this.s1R + g * (inR - this.s2R);
      const v1R  = t3R / den;
      this.s1R   = 2 * v1R - this.s1R;
      const t5R  = this.s2R + g * t3R / den;
      this.s2R   = 2 * t5R - this.s2R;
      outR = t5R;

    } else if (this.type === 'hp') {
      // svf_hp.cpp lines 163–185
      // Note: Q is smoothed as fRec0, freq as fRec5 (order swapped vs LP)
      const den = g * (g + 1 / this.qS) + 1;
      // L:
      const t3L  = this.s1L + g * (inL - this.s2L);
      const v1L  = t3L / den;
      this.s1L   = 2 * v1L - this.s1L;
      const t5L  = this.s2L + g * t3L / den;
      this.s2L   = 2 * t5L - this.s2L;
      outL = inL - (t5L + v1L / this.qS);
      // R:
      const t3R  = this.s1R + g * (inR - this.s2R);
      const v1R  = t3R / den;
      this.s1R   = 2 * v1R - this.s1R;
      const t5R  = this.s2R + g * t3R / den;
      this.s2R   = 2 * t5R - this.s2R;
      outR = inR - (t5R + v1R / this.qS);

    } else if (this.type === 'peak') {
      // svf_peak.cpp lines 174–205
      // A = 10^(gain/40) = 10^(0.025*gain)
      const A   = Math.pow(10, 0.025 * this.gainS);
      const Aq  = this.qS * A;              // fTemp1 = Q*A
      const A2m1 = A * A - 1;               // fTemp2 = A²-1
      const den = g * (g + 1 / Aq) + 1;
      // L:
      const t6L  = this.s1L + g * (inL - this.s2L);
      const v1L  = t6L / den;               // fRec4 = fTemp7
      this.s1L   = 2 * v1L - this.s1L;
      const t8L  = this.s2L + g * t6L / den;
      this.s2L   = 2 * t8L - this.s2L;
      outL = inL + v1L * A2m1 / Aq;
      // R:
      const t6R  = this.s1R + g * (inR - this.s2R);
      const v1R  = t6R / den;
      this.s1R   = 2 * v1R - this.s1R;
      const t8R  = this.s2R + g * t6R / den;
      this.s2R   = 2 * t8R - this.s2R;
      outR = inR + v1R * A2m1 / Aq;

    } else if (this.type === 'ls') {
      // svf_ls.cpp lines 174–206
      const A    = Math.pow(10, 0.025 * this.gainS);
      const sqA  = Math.sqrt(A);
      const A2m1 = A * A - 1;               // fTemp1
      const Am1  = A - 1;                   // fTemp10
      // Modified denominator using g/sqrt(A) (svf_ls.cpp line 182)
      const den  = g * (1 / this.qS + g / sqA) / sqA + 1;
      const gden = sqA * den;
      // L:
      const t6L  = this.s1L + g * (inL - this.s2L) / sqA;
      const v1L  = t6L / den;
      this.s1L   = 2 * v1L - this.s1L;
      const t9L  = this.s2L + g * t6L / gden;
      this.s2L   = 2 * t9L - this.s2L;
      outL = inL + v1L * Am1 / this.qS + t9L * A2m1;
      // R:
      const t6R  = this.s1R + g * (inR - this.s2R) / sqA;
      const v1R  = t6R / den;
      this.s1R   = 2 * v1R - this.s1R;
      const t9R  = this.s2R + g * t6R / gden;
      this.s2R   = 2 * t9R - this.s2R;
      outR = inR + v1R * Am1 / this.qS + t9R * A2m1;

    } else {
      // svf_hs.cpp lines 174–206
      const A    = Math.pow(10, 0.025 * this.gainS);
      const sqA  = Math.sqrt(A);
      const A2m1 = 1 - A * A;               // fTemp1 = 1-A²
      const Am1  = 1 - A;                   // fTemp8 = 1-A
      // Modified g: tan * sqrt(A) (svf_hs.cpp line 179)
      const gmod = g * sqA;
      const den  = gmod * (gmod + 1 / this.qS) + 1;
      // L:
      const t5L  = this.s1L + gmod * (inL - this.s2L);
      const v1L  = t5L / den;
      this.s1L   = 2 * v1L - this.s1L;
      const t7L  = this.s2L + gmod * t5L / den;
      this.s2L   = 2 * t7L - this.s2L;
      outL = A * (inL * A + v1L * Am1 / this.qS) + t7L * A2m1;
      // R:
      const t5R  = this.s1R + gmod * (inR - this.s2R);
      const v1R  = t5R / den;
      this.s1R   = 2 * v1R - this.s1R;
      const t7R  = this.s2R + gmod * t5R / den;
      this.s2R   = 2 * t7R - this.s2R;
      outR = A * (inR * A + v1R * Am1 / this.qS) + t7R * A2m1;
    }

    return [outL, outR];
  }
}
```

**Step 2: Commit**

```bash
git add public/tumult/Tumult.worklet.js
git commit -m "feat(tumult): worklet — SVF filter classes (svf_*.cpp 1:1 port)"
```

---

## Task 5: AudioWorklet — clipper, sample player, envelope follower, processor

**Files:**
- Modify: `public/tumult/Tumult.worklet.js` (append clipper + sample player + full AudioWorkletProcessor)

**Step 1: Append clipper and loop-fade sample player**

```javascript
// ─── Arctan Clipper (1:1 from hardSoftClipper.h) ──────────────────────────────
// amount: 0.05–1.0. At 1.0 = soft arctan; at 0.05 = near-hard.
function clipSample(x, amount) {
  const ax = Math.abs(x);
  if (ax < 1e-9) return x;
  return Math.sign(x) * Math.pow(Math.atan(Math.pow(ax, 1 / amount)), amount);
}

// ─── Loop-Fade Sample Player (1:1 from loopfadeplayer.h) ──────────────────────
// Plays a decoded stereo Float32Array in a crossfaded loop.
class LoopFadePlayer {
  constructor() {
    this.bufL      = null;    // Float32Array, left channel
    this.bufR      = null;    // Float32Array, right channel
    this.len       = 0;
    this.uptime    = 0;       // current read position (float samples)
    this.uptimeFade = 0;      // fade-in read head
    this.currentFade = 0;     // crossfade gain 0→1
    this.isInFade  = false;
  }

  setBuffer(bufL, bufR) {
    this.bufL = bufL;
    this.bufR = bufR;
    this.len  = bufL.length;
    this.uptime    = 0;
    this.uptimeFade = 0;
    this.currentFade = 0;
    this.isInFade  = false;
  }

  // loopfadeplayer.h port: linear interpolation, equal-power crossfade
  tick(playerStart, playerEnd, playerFade) {
    if (!this.bufL || this.len === 0) return [0, 0];

    const start     = Math.floor(playerStart * this.len);
    const end       = Math.floor(playerEnd * this.len);
    const range     = Math.max(1, end - start);
    const fadeRange = Math.floor(playerFade * range);

    // Read with linear interpolation
    const readSample = (buf, pos) => {
      const i   = Math.floor(pos) % this.len;
      const f   = pos - Math.floor(pos);
      const i2  = (i + 1) % this.len;
      return buf[i] * (1 - f) + buf[i2] * f;
    };

    const posMain = start + (this.uptime % range);
    let L = readSample(this.bufL, posMain);
    let R = readSample(this.bufR, posMain);

    // Crossfade: when approaching loop end
    if (fadeRange > 0 && this.uptime >= range - fadeRange) {
      if (!this.isInFade) {
        this.isInFade   = true;
        this.uptimeFade = 0;
        this.currentFade = 0;
      }
      // Equal-power crossfade
      const g = Math.min(1, this.currentFade / fadeRange);
      const fadePos = start + (this.uptimeFade % range);
      const fL = readSample(this.bufL, fadePos);
      const fR = readSample(this.bufR, fadePos);
      L = Math.sqrt(1 - g) * L + Math.sqrt(g) * fL;
      R = Math.sqrt(1 - g) * R + Math.sqrt(g) * fR;
      this.uptimeFade++;
      this.currentFade++;
    }

    this.uptime++;
    if (this.uptime >= range) {
      this.uptime      = this.uptimeFade;
      this.uptimeFade  = 0;
      this.currentFade = 0;
      this.isInFade    = false;
    }

    return [L, R];
  }
}

// ─── Envelope Follower (AR gate, used for Duck / Follow modes) ─────────────────
class EnvFollower {
  constructor(sr) {
    this.sr    = sr;
    this.level = 0;
    this.gate  = 0;
  }
  // attackMs, releaseMs: milliseconds
  // threshold: dB (-100..0)
  // Returns smoothed gate signal 0..1
  tick(input, threshold, attackMs, releaseMs) {
    const threshLinear = Math.pow(10, threshold / 20);
    const attackCoeff  = 1 - Math.exp(-1 / (Math.max(0.001, attackMs)  * this.sr / 1000));
    const releaseCoeff = 1 - Math.exp(-1 / (Math.max(0.001, releaseMs) * this.sr / 1000));
    const absIn = Math.abs(input);
    // Envelope detect
    if (absIn > this.level) {
      this.level += (absIn - this.level) * attackCoeff;
    } else {
      this.level += (absIn - this.level) * releaseCoeff;
    }
    // Gate signal
    const gateTarget = this.level > threshLinear ? 1 : 0;
    if (gateTarget > this.gate) {
      this.gate += (gateTarget - this.gate) * attackCoeff;
    } else {
      this.gate += (gateTarget - this.gate) * releaseCoeff;
    }
    return this.gate;
  }
}

// ─── Main AudioWorkletProcessor ───────────────────────────────────────────────
class TumultProcessor extends AudioWorkletProcessor {
  constructor() {
    super();

    this.noiseGen   = new TumultNoise(sampleRate);
    this.bands      = Array.from({ length: 5 }, () => new SVFBand(sampleRate));
    this.envFollower = new EnvFollower(sampleRate);
    this.samplePlayer = new LoopFadePlayer();

    // Default params (match TumultEffect defaults)
    this.p = {
      noiseGain: -10.6, mix: 1.0, noiseMode: 0, sourceMode: 0, switchBranch: 1,
      duckThreshold: -17.2, duckAttack: 0, duckRelease: 21.5,
      followThreshold: -10.7, followAttack: 0, followRelease: 76.9, followAmount: 0.104,
      clipAmount: 0.497,
      hpEnable: 0, hpFreq: 888.5, hpQ: 0.7,
      peak1Enable: 1, peak1Type: 0, peak1Freq: 20, peak1Gain: -0.19, peak1Q: 0.7,
      peak2Enable: 1, peak2Freq: 600, peak2Gain: 1.0, peak2Q: 1.0,
      peak3Enable: 0, peak3Type: 1, peak3Freq: 2500, peak3Gain: 1.0, peak3Q: 1.0,
      lpEnable: 0, lpFreq: 8500, lpQ: 0.7,
      sampleIndex: 0, playerStart: 0, playerEnd: 1, playerFade: 0.01, playerGain: 0,
    };

    this._updateBands();

    this.port.onmessage = (e) => {
      const { type, param, value, bufferL, bufferR } = e.data;
      if (type === 'sample') {
        this.samplePlayer.setBuffer(
          new Float32Array(bufferL),
          new Float32Array(bufferR),
        );
      } else if (param !== undefined) {
        this.p[param] = value;
        if (param.startsWith('hp') || param.startsWith('peak') || param.startsWith('lp')) {
          this._updateBands();
        }
      }
    };
  }

  _updateBands() {
    const p = this.p;
    // Band 0: HP
    this.bands[0].setParams('hp', p.hpFreq, p.hpQ, 0, !!p.hpEnable);
    // Band 1: Peak or Low Shelf
    this.bands[1].setParams(p.peak1Type ? 'ls' : 'peak', p.peak1Freq, p.peak1Q, p.peak1Gain, !!p.peak1Enable);
    // Band 2: Peak only
    this.bands[2].setParams('peak', p.peak2Freq, p.peak2Q, p.peak2Gain, !!p.peak2Enable);
    // Band 3: Peak or High Shelf
    this.bands[3].setParams(p.peak3Type ? 'hs' : 'peak', p.peak3Freq, p.peak3Q, p.peak3Gain, !!p.peak3Enable);
    // Band 4: LP
    this.bands[4].setParams('lp', p.lpFreq, p.lpQ, 0, !!p.lpEnable);
  }

  process(inputs, outputs) {
    const out0   = outputs[0];
    const outL   = out0[0];
    const outR   = out0[1] ?? out0[0];
    const inL    = inputs[0]?.[0]; // track audio for sidechain
    const inR    = inputs[0]?.[1] ?? inputs[0]?.[0];
    const p      = this.p;
    const noiseGainLin = Math.pow(10, p.noiseGain / 20);

    for (let i = 0; i < (outL?.length ?? 128); i++) {
      // ── Dry signal ──────────────────────────────────────────────────────
      const dryL = inL ? inL[i] : 0;
      const dryR = inR ? inR[i] : 0;

      // ── Noise / sample source ────────────────────────────────────────────
      let noiseL = 0, noiseR = 0;
      if (p.sourceMode === 1) {
        // Generated noise
        const n = this.noiseGen.tick(p.noiseMode);
        noiseL = noiseR = n;
      } else if (p.sourceMode === 2 || p.sourceMode === 3) {
        // Sample playback (same player for both modes)
        const pGain = p.sourceMode === 3 ? Math.pow(10, p.playerGain / 20) : 1;
        const [sL, sR] = this.samplePlayer.tick(p.playerStart, p.playerEnd, p.playerFade);
        noiseL = sL * pGain;
        noiseR = sR * pGain;
      }
      // sourceMode === 0: silence (noiseL/R stay 0)

      // ── Gate (Duck / Follow / Raw) ────────────────────────────────────────
      const sidechainIn = (dryL + dryR) / 2;
      let gateAmt = 1;
      if (p.switchBranch === 0) {
        // Duck: noise fades when signal is loud
        const g = this.envFollower.tick(sidechainIn, p.duckThreshold, p.duckAttack, p.duckRelease);
        gateAmt = 1 - g * p.followAmount;
      } else if (p.switchBranch === 1) {
        // Follow: noise plays when signal is present
        const g = this.envFollower.tick(sidechainIn, p.followThreshold, p.followAttack, p.followRelease);
        gateAmt = g * p.followAmount;
      }
      // switchBranch === 2 (Raw): gateAmt = 1

      // ── Apply noise gain + gate ───────────────────────────────────────────
      noiseL *= noiseGainLin * gateAmt;
      noiseR *= noiseGainLin * gateAmt;

      // ── Clipper (hardSoftClipper.h) ───────────────────────────────────────
      noiseL = clipSample(noiseL, p.clipAmount);
      noiseR = clipSample(noiseR, p.clipAmount);

      // ── 5-band SVF EQ ─────────────────────────────────────────────────────
      let [eqL, eqR] = [noiseL, noiseR];
      for (const band of this.bands) {
        [eqL, eqR] = band.tick(eqL, eqR);
      }

      // ── Mix dry + wet ─────────────────────────────────────────────────────
      const mix = p.mix;
      outL[i] = dryL * (1 - mix) + eqL * mix;
      outR[i] = dryR * (1 - mix) + eqR * mix;
    }

    return true;
  }
}

registerProcessor('tumult-processor', TumultProcessor);
```

**Step 2: Commit**

```bash
git add public/tumult/Tumult.worklet.js
git commit -m "feat(tumult): worklet — clipper, sample player, envelope follower, processor"
```

---

## Task 6: TumultEffect.ts wrapper

**Files:**
- Create: `src/engine/effects/TumultEffect.ts`

**Context:** Follows `VinylNoiseEffect.ts` exactly. Tone.js ToneAudioNode wrapping an AudioWorklet. The wrapper also handles sample loading: it fetches and decodes WAV files on-demand and transfers the buffers to the worklet via postMessage.

**Step 1: Create the ordered sample manifest**

At the top of `src/engine/effects/TumultEffect.ts`, the 95 sample file paths in index order (0–94), matching the Tumult UI grouping: hum → machine → static → vinyl → world → noiseplethora A → B → C.

**Step 2: Create the full TumultEffect class**

Create `src/engine/effects/TumultEffect.ts`:

```typescript
// src/engine/effects/TumultEffect.ts
/**
 * TumultEffect — noise/ambience generator.
 * 1:1 port of Tumult HISE plugin (https://github.com/Mrugalla/Tumult)
 * DSP: noise.cpp + svf_*.cpp + hardSoftClipper.h (Faust/SNEX compiled sources)
 */

import * as Tone from 'tone';

function getRawNode(node: Tone.Gain): AudioNode {
  const n = node as unknown as Record<string, AudioNode | undefined>;
  return n._gainNode ?? n._nativeAudioNode ?? n._node ?? (node as unknown as AudioNode);
}

// Ordered list of all 95 sample file paths (index = sampleIndex param).
// Group order: hum(5), machine(11), static(6), vinyl(5), world(18),
//              noiseplethora/A(17), noiseplethora/B(10), noiseplethora/C(23)
const SAMPLE_PATHS: string[] = [
  // hum (0–4)
  'hum/hum1_0ktober_hyperspace_cut.wav',
  'hum/hum2_alienhum1.wav',
  'hum/hum3_joedeshon__electrical_hum_01_cut.wav',
  'hum/hum4_loose-connection-feedback-hum.wav',
  'hum/hum5_vhs-hum.wav',
  // machine (5–15)
  'machine/machine1_computer_fan_hum_cut.wav',
  'machine/machine2_dough-machine-electricity-001_cut.wav',
  'machine/machine3_fridge-hum-kitchen-2012_cut.wav',
  'machine/machine4_fridge-hum-loud-saint-john_cut.wav',
  'machine/machine5_furnace-propane-pump-hum-rattle-nearby.wav',
  'machine/machine6_lettersort.wav',
  'machine/machine7_oven-hum-2_cut.wav',
  'machine/machine8_tattoo-air-conditioning-blowing-traffic-hum-outside_cut.wav',
  'machine/machine9_thailand-hotel-hallway-heavy-ventilation-hum-distant-voices-man-spits-middle.wav',
  'machine/machine10_vending-machine-hum_cut.wav',
  'machine/machine11_washing-machine-rinse.wav',
  // static (16–21)
  'static/static1_electric-zap-electricity-2.wav',
  'static/static2_electrical-noise.wav',
  'static/static3_film_static_03_cut.wav',
  'static/static4_gramophone_stereo.wav',
  'static/static5_radio-fuzz-for-old-radio-broadcast-ff233_cut.wav',
  'static/static6_tv-static_cut.wav',
  // vinyl (22–26)
  'vinyl/vinyl1_Runoff 139 BPM.wav',
  'vinyl/vinyl2_oldvinyl_128.wav',
  'vinyl/vinyl3_Vinyl Dust2.wav',
  'vinyl/vinyl4_Vinyl Crackle Analogue 1.wav',
  'vinyl/vinyl5_vinyl-crackle-1_edit.wav',
  // world (27–44)
  'world/city1_city-ambiance-heavy-snow-wind.wav',
  'world/city2_city-ambience-at-night-3.wav',
  'world/city3_distant-city-evening-traffic-5th-floor-balcony.wav',
  'world/crowd_large_crowd_medium_distance_stereo.wav',
  'world/fire1_ambiance_campfire_loop_stereo.wav',
  'world/fire2.wav',
  'world/fire3_campfire-01.wav',
  'world/fire4_campfire.wav',
  'world/rain1_field_la-rain_park_under-stone-bridge_02.wav',
  'world/rain2_forest-cabin-summer-rain-5.wav',
  'world/rain3_rain-and-thunder-in-the-countryside.wav',
  'world/rain4_rain-in-the-midnight-city.wav',
  'world/rain5_rain-thunder-and-traffic.wav',
  'world/underground_large-underground-metro-station-heavy-ventilation-and-distant-echo-voices.wav',
  'world/waterfall1_hidden-waterfall.wav',
  'world/waterfall2_krka_waterfall2_f_4824.wav',
  'world/waterfall3_turbulent-river-waterfall.wav',
  'world/waterfall4_sound.wav',
  // noiseplethora/A (45–61)
  'noiseplethora/A/A0-RadioOhNo_1.wav',
  'noiseplethora/A/A0-RadioOhNo_2.wav',
  'noiseplethora/A/A1-Rwalk_SineFMFlange.wav',
  'noiseplethora/A/A2-xModRingSqr.wav',
  'noiseplethora/A/A3-xModRingSine_1.wav',
  'noiseplethora/A/A3-xModRingSine_2.wav',
  'noiseplethora/A/A4-CrossModRing_1.wav',
  'noiseplethora/A/A4-CrossModRing_2.wav',
  'noiseplethora/A/A5-Resonoise_long.wav',
  'noiseplethora/A/A6-GrainGlitch_1.wav',
  'noiseplethora/A/A6-GrainGlitch_2.wav',
  'noiseplethora/A/A7-GrainGlitchII_1.wav',
  'noiseplethora/A/A7-GrainGlitchII_2.wav',
  'noiseplethora/A/A8-GrainGlitchIII_1.wav',
  'noiseplethora/A/A8-GrainGlitchIII_2.wav',
  'noiseplethora/A/A9-Basurilla_1.wav',
  'noiseplethora/A/A9-Basurilla_2.wav',
  // noiseplethora/B (62–71)
  'noiseplethora/B/B0-ClusterSaw.wav',
  'noiseplethora/B/B1-PwCluster.wav',
  'noiseplethora/B/B2-CrCluster2.wav',
  'noiseplethora/B/B3-SineFMcluster.wav',
  'noiseplethora/B/B4-TriFMcluster.wav',
  'noiseplethora/B/B5-Primecluster.wav',
  'noiseplethora/B/B6-PrimecCnoise.wav',
  'noiseplethora/B/B7-FibonacciCluster.wav',
  'noiseplethora/B/B8-PartialCluster.wav',
  'noiseplethora/B/B9-PhasingCluster.wav',
  // noiseplethora/C (72–94)
  'noiseplethora/C/C0-BasuraTotal_1.wav',
  'noiseplethora/C/C0-BasuraTotal_2.wav',
  'noiseplethora/C/C1-Atari.wav',
  'noiseplethora/C/C2-WakingFilomena_1.wav',
  'noiseplethora/C/C2-WakingFilomena_2.wav',
  'noiseplethora/C/C3-P_S_H.wav',
  'noiseplethora/C/C4-ArrayOnTheRocks_1.wav',
  'noiseplethora/C/C4-ArrayOnTheRocks_2.wav',
  'noiseplethora/C/C4-ArrayOnTheRocks_3.wav',
  'noiseplethora/C/C4-ArrayOnTheRocks_4.wav',
  'noiseplethora/C/C5-ExistencelsPain_1.wav',
  'noiseplethora/C/C5-ExistencelsPain_2.wav',
  'noiseplethora/C/C6-WhoKnows_1.wav',
  'noiseplethora/C/C6-WhoKnows_2.wav',
  'noiseplethora/C/C6-WhoKnows_3.wav',
  'noiseplethora/C/C7-SatanWorkout_1.wav',
  'noiseplethora/C/C7-SatanWorkout_2.wav',
  'noiseplethora/C/C8-Rwalk_BitCrushPW_1.wav',
  'noiseplethora/C/C8-Rwalk_BitCrushPW_2.wav',
  'noiseplethora/C/C8-Rwalk_BitCrushPW_3.wav',
  'noiseplethora/C/C9-Rwalk_LFree_1.wav',
  'noiseplethora/C/C9-Rwalk_LFree_2.wav',
  'noiseplethora/C/C9-Rwalk_LFree_3.wav',
];

export interface TumultOptions {
  noiseGain?: number;  mix?: number;  noiseMode?: number;
  sourceMode?: number; switchBranch?: number;
  duckThreshold?: number; duckAttack?: number; duckRelease?: number;
  followThreshold?: number; followAttack?: number; followRelease?: number;
  followAmount?: number; clipAmount?: number;
  hpEnable?: number; hpFreq?: number; hpQ?: number;
  peak1Enable?: number; peak1Type?: number; peak1Freq?: number; peak1Gain?: number; peak1Q?: number;
  peak2Enable?: number; peak2Freq?: number; peak2Gain?: number; peak2Q?: number;
  peak3Enable?: number; peak3Type?: number; peak3Freq?: number; peak3Gain?: number; peak3Q?: number;
  lpEnable?: number; lpFreq?: number; lpQ?: number;
  sampleIndex?: number; playerStart?: number; playerEnd?: number;
  playerFade?: number; playerGain?: number;
  wet?: number;
}

export class TumultEffect extends Tone.ToneAudioNode {
  readonly name = 'Tumult';
  readonly input:  Tone.Gain;
  readonly output: Tone.Gain;

  private dryGain: Tone.Gain;
  private wetGain: Tone.Gain;
  private workletNode: AudioWorkletNode | null = null;
  private _params: Required<TumultOptions>;
  private _loadedSampleIndex = -1;

  private static loadedContexts = new Set<BaseAudioContext>();
  private static initPromises   = new Map<BaseAudioContext, Promise<void>>();

  constructor(options: TumultOptions = {}) {
    super();
    this._params = {
      noiseGain: options.noiseGain ?? -10.6, mix: options.mix ?? 1.0,
      noiseMode: options.noiseMode ?? 0, sourceMode: options.sourceMode ?? 0,
      switchBranch: options.switchBranch ?? 1,
      duckThreshold: options.duckThreshold ?? -17.2,
      duckAttack: options.duckAttack ?? 0, duckRelease: options.duckRelease ?? 21.5,
      followThreshold: options.followThreshold ?? -10.7,
      followAttack: options.followAttack ?? 0, followRelease: options.followRelease ?? 76.9,
      followAmount: options.followAmount ?? 0.104,
      clipAmount: options.clipAmount ?? 0.497,
      hpEnable: options.hpEnable ?? 0, hpFreq: options.hpFreq ?? 888.5, hpQ: options.hpQ ?? 0.7,
      peak1Enable: options.peak1Enable ?? 1, peak1Type: options.peak1Type ?? 0,
      peak1Freq: options.peak1Freq ?? 20, peak1Gain: options.peak1Gain ?? -0.19, peak1Q: options.peak1Q ?? 0.7,
      peak2Enable: options.peak2Enable ?? 1,
      peak2Freq: options.peak2Freq ?? 600, peak2Gain: options.peak2Gain ?? 1, peak2Q: options.peak2Q ?? 1,
      peak3Enable: options.peak3Enable ?? 0, peak3Type: options.peak3Type ?? 1,
      peak3Freq: options.peak3Freq ?? 2500, peak3Gain: options.peak3Gain ?? 1, peak3Q: options.peak3Q ?? 1,
      lpEnable: options.lpEnable ?? 0, lpFreq: options.lpFreq ?? 8500, lpQ: options.lpQ ?? 0.7,
      sampleIndex: options.sampleIndex ?? 0,
      playerStart: options.playerStart ?? 0, playerEnd: options.playerEnd ?? 1,
      playerFade: options.playerFade ?? 0.01, playerGain: options.playerGain ?? 0,
      wet: options.wet ?? 1.0,
    };

    this.input   = new Tone.Gain(1);
    this.output  = new Tone.Gain(1);
    this.dryGain = new Tone.Gain(1 - this._params.wet);
    this.wetGain = new Tone.Gain(this._params.wet);

    this.input.connect(this.dryGain);
    this.dryGain.connect(this.output);
    this.wetGain.connect(this.output);

    void this._initWorklet();
  }

  private async _initWorklet() {
    try {
      const rawCtx = Tone.getContext().rawContext as AudioContext;
      await TumultEffect._ensureRegistered(rawCtx);

      this.workletNode = new AudioWorkletNode(rawCtx, 'tumult-processor', {
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [2],
      });

      const rawInput = getRawNode(this.input);
      const rawWet   = getRawNode(this.wetGain);
      rawInput.connect(this.workletNode);
      this.workletNode.connect(rawWet);

      // Push all current params
      const p = this._params;
      for (const [k, v] of Object.entries(p) as [string, number][]) {
        if (k !== 'wet') this._send(k, v);
      }

      // Load sample if sourceMode needs one
      if (p.sourceMode === 2 || p.sourceMode === 3) {
        void this._loadSample(p.sampleIndex);
      }
    } catch (err) {
      console.warn('[Tumult] Worklet init failed:', err);
      this.input.connect(this.wetGain);
    }
  }

  private static async _ensureRegistered(ctx: AudioContext): Promise<void> {
    if (this.loadedContexts.has(ctx)) return;
    const existing = this.initPromises.get(ctx);
    if (existing) return existing;
    const p = (async () => {
      const base = (import.meta as { env?: { BASE_URL?: string } }).env?.BASE_URL ?? '/';
      await ctx.audioWorklet.addModule(`${base}tumult/Tumult.worklet.js`);
      this.loadedContexts.add(ctx);
    })();
    this.initPromises.set(ctx, p);
    return p;
  }

  private _send(param: string, value: number) {
    this.workletNode?.port.postMessage({ param, value });
  }

  private async _loadSample(index: number) {
    if (index === this._loadedSampleIndex) return;
    const path = SAMPLE_PATHS[index];
    if (!path) return;
    try {
      const base  = (import.meta as { env?: { BASE_URL?: string } }).env?.BASE_URL ?? '/';
      const url   = `${base}tumult/samples/${path}`;
      const resp  = await fetch(url);
      const ab    = await resp.arrayBuffer();
      const rawCtx = Tone.getContext().rawContext as AudioContext;
      const buf   = await rawCtx.decodeAudioData(ab);

      // Extract channel data
      const bufL = buf.getChannelData(0).slice();
      const bufR = (buf.numberOfChannels > 1 ? buf.getChannelData(1) : buf.getChannelData(0)).slice();

      this.workletNode?.port.postMessage(
        { type: 'sample', bufferL: bufL.buffer, bufferR: bufR.buffer, length: bufL.length },
        [bufL.buffer, bufR.buffer],
      );
      this._loadedSampleIndex = index;
    } catch (err) {
      console.warn('[Tumult] Sample load failed:', err);
    }
  }

  // ─── Parameter setters ─────────────────────────────────────────────────────

  set(param: keyof TumultOptions, value: number) {
    (this._params as Record<string, number>)[param] = value;
    if (param === 'wet') {
      this.wetGain.gain.value = value;
      this.dryGain.gain.value = 1 - value;
    } else {
      this._send(param, value);
    }
    // Trigger sample load when switching source or sample index
    if (param === 'sampleIndex' || param === 'sourceMode') {
      const p = this._params;
      if (p.sourceMode === 2 || p.sourceMode === 3) {
        void this._loadSample(p.sampleIndex);
      }
    }
  }

  dispose(): this {
    try { this.workletNode?.disconnect(); } catch { /* */ }
    this.workletNode = null;
    this.dryGain.dispose();
    this.wetGain.dispose();
    this.input.dispose();
    this.output.dispose();
    super.dispose();
    return this;
  }
}
```

**Step 3: Verify TypeScript compiles**

```bash
cd /Users/spot/Code/DEViLBOX && npx tsc --noEmit 2>&1 | grep -i tumult
```
Expected: no errors.

**Step 4: Commit**

```bash
git add src/engine/effects/TumultEffect.ts
git commit -m "feat(tumult): TumultEffect.ts — Tone.js wrapper with sample loading"
```

---

## Task 7: TumultEditor React component

**Files:**
- Modify: `src/components/effects/VisualEffectEditors.tsx`

**Context:** Follow `VinylNoiseEditor` pattern exactly: read params via `getParam()`, use `onUpdateParameter(key, value)` for changes, use `SectionHeader`, `Knob`, and existing UI primitives. Use `configRef` pattern from CLAUDE.md to prevent stale state. No emojis. Lucide React icons only.

**Step 1: Read the top imports section of VisualEffectEditors.tsx to understand what primitives are available**

Check imports at top of file:
```bash
head -60 src/components/effects/VisualEffectEditors.tsx
```

**Step 2: Add sample category data and the TumultEditor component**

Find the `export const VinylNoiseEditor` line and insert the following **before** it (after the VINYL_CONDITION_PRESETS constant):

```typescript
// ─── Tumult sample categories (mirrors SAMPLE_PATHS order in TumultEffect.ts) ──
const TUMULT_CATEGORIES = [
  { label: 'Hum',        start: 0,  end: 4,  subcats: null },
  { label: 'Machine',    start: 5,  end: 15, subcats: null },
  { label: 'Static',     start: 16, end: 21, subcats: null },
  { label: 'Vinyl',      start: 22, end: 26, subcats: null },
  { label: 'World',      start: 27, end: 44, subcats: null },
  { label: 'Plethora A', start: 45, end: 61, subcats: null },
  { label: 'Plethora B', start: 62, end: 71, subcats: null },
  { label: 'Plethora C', start: 72, end: 94, subcats: null },
] as const;

// Short display names for each sample (index = sampleIndex)
const TUMULT_SAMPLE_NAMES: string[] = [
  // hum
  'Hyperspace','Alien Hum','Elec Hum','Feedback','VHS Hum',
  // machine
  'Fan','Dough','Fridge 1','Fridge 2','Furnace','Lettersort',
  'Oven','Tattoo AC','Hotel Vent','Vending','Washing',
  // static
  'Elec Zap','Elec Noise','Film Static','Gramophone','Radio Fuzz','TV Static',
  // vinyl
  'Runoff','Old Vinyl','Vinyl Dust','Analogue','Vinyl Crackle',
  // world
  'City Snow','City Night','City Traffic','Crowd','Campfire 1','Fire 2','Campfire 3','Campfire 4',
  'Rain LA','Forest Rain','Thunder Rain','City Rain','Traffic Rain','Metro','Waterfall 1',
  'Waterfall 2','Waterfall 3','Waterfall 4',
  // noiseplethora A
  'A0 Radio 1','A0 Radio 2','A1 SineFM','A2 RingSqr',
  'A3 RingSine 1','A3 RingSine 2','A4 CrossMod 1','A4 CrossMod 2',
  'A5 Resonoise','A6 Grain 1','A6 Grain 2','A7 Grain3 1','A7 Grain3 2',
  'A8 Grain4 1','A8 Grain4 2','A9 Basurilla 1','A9 Basurilla 2',
  // noiseplethora B
  'B0 ClusterSaw','B1 PwCluster','B2 CrCluster','B3 SineFM',
  'B4 TriFM','B5 Prime','B6 PrimeCnoise','B7 Fibonacci','B8 Partial','B9 Phasing',
  // noiseplethora C
  'C0 Basura 1','C0 Basura 2','C1 Atari','C2 Filomena 1','C2 Filomena 2',
  'C3 PSH','C4 Array 1','C4 Array 2','C4 Array 3','C4 Array 4',
  'C5 Exists 1','C5 Exists 2','C6 WhoKnows 1','C6 WhoKnows 2','C6 WhoKnows 3',
  'C7 Satan 1','C7 Satan 2','C8 BitCrush 1','C8 BitCrush 2','C8 BitCrush 3',
  'C9 LFree 1','C9 LFree 2','C9 LFree 3',
];

export const TumultEditor: React.FC<VisualEffectEditorProps> = ({
  effect,
  onUpdateParameter,
}) => {
  const configRef = useRef(effect);
  useEffect(() => { configRef.current = effect; }, [effect]);

  const p = (key: string, def: number) => getParam(effect, key, def);

  const sourceMode  = p('sourceMode', 0);
  const noiseMode   = p('noiseMode', 0);
  const switchBranch = p('switchBranch', 1);
  const sampleIndex  = p('sampleIndex', 0);
  const activeCat   = TUMULT_CATEGORIES.find(c => sampleIndex >= c.start && sampleIndex <= c.end);

  const set = useCallback((key: string, value: number) => {
    onUpdateParameter(key, value);
  }, [onUpdateParameter]);

  const SOURCE_LABELS = ['Off', 'Synth', 'Sample', 'Custom'] as const;
  const NOISE_LABELS  = ['White', 'Pink', 'Brown', 'Velvet', 'Crushed'] as const;
  const BRANCH_LABELS = ['Duck', 'Raw', 'Follow'] as const;

  const btnBase = 'flex-1 py-1.5 rounded-lg text-xs font-bold border transition-all';
  const btnActive = 'bg-violet-700/70 border-violet-500 text-violet-100';
  const btnInactive = 'bg-black/40 border-border text-text-muted hover:border-violet-700 hover:text-violet-300';

  return (
    <div className="space-y-4">
      {/* ── Section 1: Source ─────────────────────────────────────────────── */}
      <section className="rounded-xl p-4 border border-border bg-black/30 backdrop-blur-sm shadow-inner-dark">
        <SectionHeader color="#7c3aed" title="Source" />

        {/* Source mode tabs */}
        <div className="flex gap-2 mb-3">
          {SOURCE_LABELS.map((label, i) => (
            <button key={label} onClick={() => set('sourceMode', i)}
              className={`${btnBase} ${sourceMode === i ? btnActive : btnInactive}`}>
              {label}
            </button>
          ))}
        </div>

        {/* Synth: noise type selector */}
        {sourceMode === 1 && (
          <div className="flex gap-2">
            {NOISE_LABELS.map((label, i) => (
              <button key={label} onClick={() => set('noiseMode', i)}
                className={`${btnBase} ${noiseMode === i ? btnActive : btnInactive}`}>
                {label}
              </button>
            ))}
          </div>
        )}

        {/* Sample: category + sample picker */}
        {sourceMode === 2 && (
          <>
            <div className="flex gap-1.5 mb-2 flex-wrap">
              {TUMULT_CATEGORIES.map((cat) => (
                <button key={cat.label}
                  onClick={() => set('sampleIndex', cat.start)}
                  className={`px-2 py-1 rounded text-xs font-bold border transition-all ${
                    activeCat?.label === cat.label ? btnActive : btnInactive
                  }`}>
                  {cat.label}
                </button>
              ))}
            </div>
            {activeCat && (
              <div className="flex gap-1.5 flex-wrap">
                {Array.from({ length: activeCat.end - activeCat.start + 1 }, (_, i) => {
                  const idx = activeCat.start + i;
                  return (
                    <button key={idx} onClick={() => set('sampleIndex', idx)}
                      className={`px-2 py-1 rounded text-xs border transition-all ${
                        sampleIndex === idx ? btnActive : btnInactive
                      }`}>
                      {TUMULT_SAMPLE_NAMES[idx]}
                    </button>
                  );
                })}
              </div>
            )}
          </>
        )}
      </section>

      {/* ── Section 2: Master Controls ────────────────────────────────────── */}
      <section className="rounded-xl p-4 border border-border bg-black/30 backdrop-blur-sm shadow-inner-dark">
        <SectionHeader color="#7c3aed" title="Controls" />

        <div className="flex gap-6 items-start">
          <Knob label="Gain" value={p('noiseGain', -10.6)} min={-35} max={35}
            unit="dB" onChange={(v) => set('noiseGain', v)} />
          <Knob label="Mix" value={p('mix', 1)} min={0} max={1}
            onChange={(v) => set('mix', v)} />
          <Knob label="Clip" value={p('clipAmount', 0.497)} min={0.05} max={1}
            onChange={(v) => set('clipAmount', v)} />

          {/* Duck / Raw / Follow switch */}
          <div className="flex flex-col gap-1">
            <span className="text-xs text-text-muted mb-1">Mode</span>
            <div className="flex gap-1.5">
              {BRANCH_LABELS.map((label, i) => {
                // Map display order (Duck=0, Raw=1, Follow=2) to switchBranch (0=Duck, 2=Raw, 1=Follow)
                const val = i === 0 ? 0 : i === 1 ? 2 : 1;
                return (
                  <button key={label} onClick={() => set('switchBranch', val)}
                    className={`px-3 py-1 rounded text-xs font-bold border transition-all ${
                      switchBranch === val ? btnActive : btnInactive
                    }`}>
                    {label}
                  </button>
                );
              })}
            </div>
          </div>
        </div>

        {/* Duck params */}
        {switchBranch === 0 && (
          <div className="flex gap-4 mt-3 pt-3 border-t border-border">
            <Knob label="Threshold" value={p('duckThreshold', -17.2)} min={-100} max={0}
              unit="dB" onChange={(v) => set('duckThreshold', v)} />
            <Knob label="Attack" value={p('duckAttack', 0)} min={0} max={500}
              unit="ms" onChange={(v) => set('duckAttack', v)} />
            <Knob label="Release" value={p('duckRelease', 21.5)} min={0} max={500}
              unit="ms" onChange={(v) => set('duckRelease', v)} />
          </div>
        )}

        {/* Follow params */}
        {switchBranch === 1 && (
          <div className="flex gap-4 mt-3 pt-3 border-t border-border">
            <Knob label="Threshold" value={p('followThreshold', -10.7)} min={-100} max={0}
              unit="dB" onChange={(v) => set('followThreshold', v)} />
            <Knob label="Attack" value={p('followAttack', 0)} min={0} max={500}
              unit="ms" onChange={(v) => set('followAttack', v)} />
            <Knob label="Release" value={p('followRelease', 76.9)} min={0} max={500}
              unit="ms" onChange={(v) => set('followRelease', v)} />
            <Knob label="Amount" value={p('followAmount', 0.104)} min={0} max={1}
              onChange={(v) => set('followAmount', v)} />
          </div>
        )}
      </section>

      {/* ── Section 3: 5-Band EQ ──────────────────────────────────────────── */}
      <section className="rounded-xl p-4 border border-border bg-black/30 backdrop-blur-sm shadow-inner-dark">
        <SectionHeader color="#7c3aed" title="EQ" />

        <div className="flex gap-4">
          {/* Band 1: HP */}
          <EQBand label="HP" enableKey="hpEnable" freqKey="hpFreq" qKey="hpQ"
            enabled={!!p('hpEnable', 0)} freq={p('hpFreq', 888.5)} q={p('hpQ', 0.7)}
            onSet={set} showGain={false} />
          {/* Band 2: Peak / Low Shelf */}
          <EQBand label="Low" enableKey="peak1Enable" freqKey="peak1Freq"
            gainKey="peak1Gain" qKey="peak1Q" typeKey="peak1Type"
            enabled={!!p('peak1Enable', 1)} freq={p('peak1Freq', 20)}
            gain={p('peak1Gain', -0.19)} q={p('peak1Q', 0.7)}
            filterType={p('peak1Type', 0)} typeLabels={['Bell', 'Lo Shelf']}
            onSet={set} showGain />
          {/* Band 3: Peak only */}
          <EQBand label="Mid" enableKey="peak2Enable" freqKey="peak2Freq"
            gainKey="peak2Gain" qKey="peak2Q"
            enabled={!!p('peak2Enable', 1)} freq={p('peak2Freq', 600)}
            gain={p('peak2Gain', 1)} q={p('peak2Q', 1)}
            onSet={set} showGain />
          {/* Band 4: Peak / High Shelf */}
          <EQBand label="High" enableKey="peak3Enable" freqKey="peak3Freq"
            gainKey="peak3Gain" qKey="peak3Q" typeKey="peak3Type"
            enabled={!!p('peak3Enable', 0)} freq={p('peak3Freq', 2500)}
            gain={p('peak3Gain', 1)} q={p('peak3Q', 1)}
            filterType={p('peak3Type', 1)} typeLabels={['Bell', 'Hi Shelf']}
            onSet={set} showGain />
          {/* Band 5: LP */}
          <EQBand label="LP" enableKey="lpEnable" freqKey="lpFreq" qKey="lpQ"
            enabled={!!p('lpEnable', 0)} freq={p('lpFreq', 8500)} q={p('lpQ', 0.7)}
            onSet={set} showGain={false} />
        </div>
      </section>
    </div>
  );
};

// EQ band sub-component (local, not exported)
const EQBand: React.FC<{
  label: string;
  enableKey: string; freqKey: string; gainKey?: string; qKey: string; typeKey?: string;
  enabled: boolean; freq: number; gain?: number; q: number; filterType?: number;
  typeLabels?: [string, string];
  onSet: (k: string, v: number) => void;
  showGain: boolean;
}> = ({ label, enableKey, freqKey, gainKey, qKey, typeKey, enabled, freq, gain, q,
        filterType, typeLabels, onSet, showGain }) => (
  <div className="flex-1 flex flex-col gap-2">
    <div className="flex items-center justify-between">
      <span className="text-xs font-bold text-text-secondary">{label}</span>
      <button
        onClick={() => onSet(enableKey, enabled ? 0 : 1)}
        className={`w-4 h-4 rounded-sm border transition-all ${
          enabled ? 'bg-violet-500 border-violet-400' : 'bg-black/40 border-border'
        }`}
      />
    </div>
    {typeKey && typeLabels && (
      <div className="flex gap-1">
        {typeLabels.map((t, i) => (
          <button key={t} onClick={() => onSet(typeKey, i)}
            className={`flex-1 py-0.5 rounded text-[10px] border transition-all ${
              filterType === i
                ? 'bg-violet-700/70 border-violet-500 text-violet-100'
                : 'bg-black/40 border-border text-text-muted'
            }`}>
            {t}
          </button>
        ))}
      </div>
    )}
    <Knob label="Freq" value={freq} min={20} max={20000} unit="Hz"
      onChange={(v) => onSet(freqKey, v)} size="sm" />
    {showGain && gainKey && (
      <Knob label="Gain" value={gain ?? 0} min={-24} max={24} unit="dB"
        onChange={(v) => onSet(gainKey, v)} size="sm" />
    )}
    <Knob label="Q" value={q} min={0.7} max={10}
      onChange={(v) => onSet(qKey, v)} size="sm" />
  </div>
);
```

**Step 3: Register TumultEditor in the editor map**

Find the `EFFECT_EDITORS` map (around line 2620) and add:
```typescript
  Tumult: TumultEditor,
```

Find the `EFFECT_THEME_COLORS` map (around line 2688) and add:
```typescript
  Tumult: { bg: '#0d0a1a', bgEnd: '#080612', accent: '#7c3aed', border: '#1a1030' },
```

Find the `EFFECT_ICONS` map (around line 2759) and add:
```typescript
  Tumult: <Radio size={18} className="text-white" />,
```

**Step 4: Verify TypeScript compiles**

```bash
cd /Users/spot/Code/DEViLBOX && npx tsc --noEmit 2>&1 | grep -i tumult
```
Expected: no errors.

**Step 5: Commit**

```bash
git add src/components/effects/VisualEffectEditors.tsx
git commit -m "feat(tumult): TumultEditor React component — source, controls, 5-band EQ"
```

---

## Task 8: Smoke test

**No automated tests exist for audio DSP in this codebase.** Manual verification steps:

**Step 1: Start dev server**
```bash
cd /Users/spot/Code/DEViLBOX && npm run dev
```

**Step 2: Add Tumult to any instrument's effect chain**
- Open the app, pick any instrument, open its effect chain
- Click "Add Effect" → Texture → "Tumult" should appear
- Add it

**Step 3: Verify noise generation (sourceMode=1)**
- Set Source → Synth
- Enable the instrument, play a note
- You should hear noise. Switch through White/Pink/Brown/Velvet/Crushed — each should sound distinct.

**Step 4: Verify sample playback (sourceMode=2)**
- Set Source → Sample
- Pick "Hum" category → "Hyperspace"
- You should hear the looping WAV file mixed into the output

**Step 5: Verify EQ**
- Enable HP band, set Freq to 1000 Hz — noise should become thin
- Enable LP band, set Freq to 500 Hz — noise should become muffled

**Step 6: Verify Duck/Follow**
- Set Mode → Duck
- Play audio — noise should attenuate when signal is present

**Step 7: Final commit**
```bash
git add -A
git commit -m "feat(tumult): complete Tumult effect port — smoke test passing"
```

---

## Notes for the implementer

- **noise.cpp port:** The 12-stage colored noise chain is computed per-tick. The state update for each stage must happen AFTER the output is computed (forward pass), not during. Copy the stage update pattern exactly from the C++ loop — each `fRecN[1] = fRecN[0]` happens at the end of the sample loop.
- **SVFBand:** The smoothing constants `alpha = 44.1/SR` and `oneMA = 1 - 44.1/SR` create a 10 Hz one-pole IIR identical to the Faust source. This makes parameter changes audibly smooth without zipper noise.
- **Sample transfer:** Use `Transferable` (`ArrayBuffer`) when posting sample data to the worklet — avoids copying multi-MB arrays.
- **Knob `size="sm"` prop:** Used in existing EQ editors — check that the Knob component accepts it, fall back to omitting it if not.
- **`useRef` / `configRef`:** Required by CLAUDE.md for all controls. Already included in `TumultEditor`.
