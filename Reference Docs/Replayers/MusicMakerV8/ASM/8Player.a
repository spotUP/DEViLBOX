;
; 8Player
;
; Example Program: Play an 8-channel-song.
;
; DOES NOT USE ANY OF THE MM-LIBRARIES. FOR USING THE
; LIBRARIES, SEE "Radio" AND "URadio" EXAMPLES.
;
; THIS PROGRAM IS BASED ON THE "8-Channel-Player.a"
;
; REQUIRED FILES FOR PLAYING A SONG:
;    .sdata
;    .i or .ip, where the LIB-DISK-Mode is NOT supported.
;
;
; Written by The Dire Cracks, Inc.
;

; AVAILABLE PLAYER ROUTINES:
  xref _soundon,_soundoff,_generalsndinit,_generalsndremove
  xref _generalsndreset,_fadesnd,_waitfade,_loadandinit
  xref _removeloaded,_waitoneshotfin,_decrunchinstrs
  xref _setvolume,_getunpackedinstlen,_isstdsong,_obtainmixbuflen
  xref _setmixbuffers,_setalertreaction,_newmaketables
  xref _lockaudio,_unlockaudio,_setupcachecontrol


 SECTION Pseudo,CODE          ; We're running stand-alone from CLI

start:
 bra.s realstart
 dc.b '$VER: MM_V8-8Player V3.1 (11 Jan 1994)',$0d,$0a
 cnop 0,2
realstart:
 lea.l argvBuffer,a2          ; CLI - Parameters
 lea.l argvArray,a3
 moveq.l #0,d2
3$: move.b (a0)+,d1
    subq.l #1,d0
    bls.s parmExit
    cmpi.b #' ',d1
     bls.s 3$
    addq.l #1,d2
    move.l a2,(a3)+
    bra.s 5$
4$: move.b (a0)+,d1
    subq.l #1,d0
    cmpi.b #' ',d1
     bls.s 6$
5$: move.b d1,(a2)+
    bra.s 4$
6$: clr.b (a2)+
    bra.s 3$
parmExit:
 clr.b (a2)+
 clr.l (a3)+
 move.l d2,argc

 lea.l start-4(PC),a0
 clr.l (a0)
 move.l $4,a6
 lea.l dosname,a1
 jsr -408(a6)
 move.l d0,a6
 move.l #procname,d1
 moveq.l #0,d2
 move.l #procstart-4,d3
 lsr.l #2,d3
 move.l #4096,d4
 jsr -138(a6)              ; Create 8Player-Process, and
 moveq.l #0,d0             ; RETURN to CLI !
 rts



 SECTION 8Player,CODE

procstart:
 move.l 4,a6               ; OpenLib stuff for:
 lea.l dosname(PC),a1
 jsr -408(a6)
 move.l d0,dosbase         ;    dos.library
 lea.l intname(PC),a1
 jsr -408(a6)
 move.l d0,intbase         ;    intuition.library

 moveq.l #1,d0
 cmp.l argc(PC),d0
 beq.s ok_inp1
  bsr FLASH
  bra EXIT
ok_inp1:                   ; we're right here now: parameters are correct


; *********************************************************************
; The following part does the loading stuff. This could easily be done
; by using _loadandinit, which is now also available in the mplayer
; module (and in mmv88.library, of course). But for the sake of the
; EXAMPLE, this time we do it all "manually". Note: This is for demo
; only, thou really shalt use LoadAndInit(). It shows how to use
; init routines in case DOS is void. (Bootblock loading, etc.)

 move.l argvArray,a0
 lea.l macrosfile,a1    ; create <FILE>.sdata and <FILE>.i
 lea.l instrsfile,a2
namecopyloop:
  move.b (a0),(a1)+
  move.b (a0)+,(a2)+
 bne.s namecopyloop
 move.b #'.',-1(a1)
 move.b #'s',(a1)+
 move.b #'d',(a1)+
 move.b #'a',(a1)+
 move.b #'t',(a1)+
 move.b #'a',(a1)+
 clr.b (a1)
 move.b #'.',-1(a2)
 move.b #'i',(a2)+
 clr.b (a2)
 move.l a2,ifilenameendptr

 move.l dosbase(PC),a6     ; "LVOexamine" files to find filelength
 move.l #macrosfile,d1
 bsr examinefile
 move.l d0,macroslength
 bmi fileopenerror
 sf packedflag
 move.l #instrsfile,d1
 bsr examinefile
 move.l d0,instrslength    ; if no ".i"-file, then try ".ip"
 bpl.s ifileavailable
  move.l ifilenameendptr(PC),a0
  move.b #'p',(a0)+        ; append "p"
  clr.b (a0)
  move.l #instrsfile,d1
  bsr examinefile
  move.l d0,instrslength
  bmi fileopenerror
  st packedflag
ifileavailable:

 move.l $4,a6
 move.l instrslength(PC),d0
 move.l #$10001,d1
 jsr -198(a6)          ; allocmem for instrs (.i-File)
 move.l d0,instrdata
 beq error1

 move.l macroslength(PC),d0
 move.l #$10001,d1
 jsr -198(a6)          ; allocmem for melody (.sdata-file)
 move.l d0,macrosdata
 beq error2

 move.l dosbase(PC),a6
 move.l #instrsfile,d1      ; LOAD INSTRUMENTS
 move.l #1005,d2
 jsr -30(a6)
 move.l d0,d7
 beq fileerror1
 move.l d0,d1
 move.l instrdata(PC),d2
 move.l instrslength(PC),d3
 jsr -42(a6)
 move.l d7,d1
 jsr -36(a6)
 tst.b packedflag
 bne.s nolib1
  move.l instrdata(PC),a0     ; Check if LIB-DISK mode.
  moveq.l #-1,d0              ; In the future, this 
  cmp.l (a0)+,d0              ; verification may change.
  bne.s nolib1                ; You really shound use the
  cmp.l (a0),d0               ; _loadandinit function in
  beq fileerror1              ; universal replayer programs.
nolib1:

 move.l #macrosfile,d1    ; LOAD MACROS&MELODY (.sdata)
 move.l #1005,d2
 jsr -30(a6)
 move.l d0,d7
 beq fileerror1
 move.l d0,d1
 move.l macrosdata(PC),d2
 move.l macroslength(PC),d3
 jsr -42(a6)
 move.l d7,d1
 jsr -36(a6)
 move.l macrosdata(PC),a0    ; check if 8-Channel-song
 jsr _isstdsong
 tst.l d0
 bne fileerror1


; ==== START OF SOUND-INITIALIZATION: =========================


; 1.STEP: Eventually unpack instruments:

 tst.b packedflag
 beq isNOTpacked
  move.l instrdata(PC),a0
  jsr _getunpackedinstlen ; calculate memory requirement of unpacked
  move.l d0,d1            ; instruments
  move.l instrslength(PC),realinstrslen
  move.l d1,instrslength
  move.l $4,a6
  move.l d1,d0
  move.l #$10001,d1
  jsr -198(a6)
  tst.l d0
  beq fileerror1
  move.l instrdata(PC),realinstrdata
  move.l d0,instrdata
  move.l realinstrdata(PC),a0
  move.l d0,a1
  jsr _decrunchinstrs     ; ... and decrunch
isNOTpacked:


; 2.STEP: I NEED 8 MIXBUFFERS in CHIP-RAM

 move.l macrosdata(PC),a0
 jsr _obtainmixbuflen     ; find mixbufferlength for this song
 move.l d0,mixbuflen      ; (depends on speed and hi-table)

 move.l $4,a6
 move.l mixbuflen(PC),d0
 lsl.l #3,d0              ; 8 buffers required
 move.l #$10003,d1        ; CHIP-RAM!!!
 jsr -198(a6)             ; allocmem for MIXBUFFERS
 move.l d0,mixbufferstart
 beq mixbuffermemerror
 move.l d0,a0
 move.l mixbuflen(PC),d0
 moveq.l #8-1,d1          ; example for setting up a vector field as
mixfieldbuildloop:        ; needed for "_setmixbuffers"
  move.l a0,-(a7)
  adda.w d0,a0
 dbra d1,mixfieldbuildloop
 move.l a7,a0
 jsr _setmixbuffers       ; setup vectorfield to player
 lea.l 8*4(a7),a7


; 3.STEP: Create another table required

 move.l 4,a6
 move.l #4544+(64*256),d0 ; Length of table in THIS case; (see below)
 move.l #$10001,d1
 jsr -198(a6)             ; allocmem for table (chip not required)
 move.l d0,tablemem
 beq tablememerror
 move.l d0,a0             ; now fill up table with data:
;                                free space of 4544+(64*d1) bytes
 moveq.l #-1,d1    ; -in this case: table unpacked:     /\
 jsr _newmaketables  ;  memory requirement: packed   128,256 when unpacked



; INTERLUDE, can be done at any point: Set up reaction in case of emergency
 moveq.l #0,d0          ;   STOP if mixing takes more time than allowed
 jsr _setalertreaction  ;    (analogy to "Mix-Player Emergency"-Flag in MM!)



; INTERLUDE: Open our window
 move.l intbase(PC),a6
 lea.l mywindow(PC),a0
 cmpi.w #37,20(a6)
 bcs.s 1$
   lea.l windowtags(PC),a1
   jsr -606(a6)
   bra.s 2$
1$:
 jsr -204(a6)
2$:
 move.l d0,window
  beq cantopenwindow
 move.l d0,a0
 move.l 86(a0),userport
; ----------



; INTERLUDE: Lock away audio.device; can be done at any point

  jsr _lockaudio           ; lock audio.device to avoid interphere
  move.b d0,audopen        ; returns FALSE, if it could NOT get locked
                           ; YOU SHOULD CARE ABOUT THIS !!!


; 4.STEP: Call sound initialization
  moveq.l #0,d0            ; play 0=loop, <>0=oneshot
  move.l instrdata(PC),a1
  move.l macrosdata(PC),a2
  suba.l a3,a3       ; or lea.l myprivateroutine(PC),a3 to handle "$"s
  jsr _generalsndinit



;*************************************************************************
; The following is REALLY important:
; Starting version 3, the mplayer features SetupCacheControl() to handle
; 68020,30,40 caches and 68040 CachePreDMA(). By default, the caches are
; ignored. On machines equipped with 68040, especially, this can be
; troubleful in case COPYBACK mode is ON. Arguments to this functions
; are: d0: Kickstart version, because ClearCache() and CachePreDMA() are
;          supported from 37, yet.
;      d1: System-Attn Flags from Execbase for sensing the CPU type.
;
; This function MUST be called AFTER a song has been initialized.
;
; NOTE: The mplayer module requires a CORRECTLY INITIALIZED
; ¯¯¯¯¯ ExecBase area due to VBR handling routines inside  !!!!

 move.l $4,a0
 move.w 20(a0),d0    ; execbase->Version
 move.w 296(a0),d1   ; execbase-> AttnFlags
 jsr _setupcachecontrol      ; SetupCacheControl()

;*************************************************************************



; switch off the low pass filter
  bset.b #1,$bfe001


; FINAL STEP: SWITCH sound ON
  jsr _soundon


; === NOW DO ANYTHING YOU WANT
; (we wait for a window-message)
nogoodmsg:                  ; The intuition-message stuff
  move.l $4,a6
  move.l userport(PC),a0
  jsr -384(a6)
  move.l userport(PC),a0
  jsr -372(a6)
  move.l d0,a1
  move.l 20(a1),d2
  jsr -378(a6)
  move.l d2,d3
  andi.l #$00000200,d2      ; close-gadget ???  -> QUIT
   bne.s endofplay
  andi.l #$00000040,d3      ; gadgup ??? -> Volume Button !
   bne.s recalcvolume
 bra.s nogoodmsg

recalcvolume: ; ---------- user set a new volume:
 lea.l prop1(PC),a0
 moveq.l #0,d0
 move.w 2(a0),d0
 divu 6(a0),d0
 jsr _setvolume         ; Set general volume ...
 bra.s nogoodmsg        ;  ... and back to WaitPort-Loop

endofplay:    ; ---------- end of program
;                     FADE SOUND OUT after closing-gadget has been activated
  moveq.l #110,d0   ; fadespeed 50(=very fast) - 126 (slow)
  jsr _fadesnd
waitforfade:        ; wait for the fading to finish
   jsr _waitfade
   tst.l d0
 beq.s waitforfade


; SWITCHING SOUND OFF IMMEDIATLY; this MUST be done after fading out!
 jsr _soundoff


; SWITCHING LOW PASS FILTER TO ORIG STATE
 bclr.b #1,$bfe001



; IF YOU WANT YOUR SOUND START AGAIN, DO THE FOLLOWING:
; moveq.l #0,d0  OR  moveq.l #1,d0   FOR LOOP/ONESHOT
; jsr _generalsndreset
; jsr _soundon


; IF YOU WANT TO PLAY ANOTHER SOUND, YOU SIMPLY CALL
; jsr _generalsndinit  INSTEAD OF _generalsndreset
; WITH THE REGISTERS SET AS FAR ABOVE.



; THIS IS MY EXIT-STUFF: ---------------------------------------

 jsr _generalsndremove   ; restore interrupt vector (was set up by GeneralSndInit)

 tst.b audopen
 beq.s 2$
   jsr _unlockaudio      ; unlock audio.device
2$:

 bsr closewindow
 tst.b packedflag
 beq.s 1$
   bsr freepackmem
1$:
 bsr freetable
 bsr freemixbuffers
 bsr freememmelody
 bsr freememinstrs
EXIT:
 move.l $4,a6
 jsr -132(a6)              ; FORBID
 move.l dosbase(PC),a6
 move.l #procstart-4,d1
 lsr.l #2,d1
 jsr -156(a6)              ; UnLoad our Segment
 moveq.l #0,d0
 rts                       ; AND: So far - So long - See ya ...

cantopenwindow:
 bsr freetable
tablememerror:
 bsr freemixbuffers
mixbuffermemerror:
 tst.b packedflag
 beq.s fileerror1
   bsr freepackmem
fileerror1:
 bsr FLASH
 bsr freememmelody
error2:
 bsr freememinstrs
error1:
 bra EXIT

freepackmem:
 move.l 4,a6
 move.l realinstrslen(PC),d0
 move.l realinstrdata(PC),a1
 jmp -210(a6)

freememinstrs:
 move.l 4,a6
 move.l instrslength(PC),d0
 move.l instrdata(PC),a1
 jmp -210(a6)

freememmelody:
 move.l 4,a6
 move.l macroslength(PC),d0
 move.l macrosdata(PC),a1
 jmp -210(a6)

freetable:
 move.l 4,a6
 move.l #(64*2)+(65*32*2)+(64*256),d0
 move.l tablemem(PC),a1
 jmp -210(a6)

freemixbuffers:
 move.l 4,a6
 move.l mixbuflen(PC),d0
 lsl.l #3,d0
 move.l mixbufferstart(PC),a1
 jmp -210(a6)

closewindow:
 move.l intbase(PC),a6     ; Finish up with my window
 move.l window(PC),a0
 jmp -72(a6)

examinefile:
 moveq.l #-2,d2
 jsr -84(a6)
 move.l d0,d7
 beq.s filenotfound
 move.l d0,d1
 move.l #fileinfo,d2
 jsr -102(a6)
 move.l d7,d1
 jsr -90(a6)
 move.l fileinfo+124,d0
 rts
filenotfound:
 moveq.l #-1,d0
 rts

fileopenerror:
 bsr.s FLASH
 bra EXIT

FLASH:
 suba.l a0,a0
 move.l intbase(PC),a6
 jmp -96(a6)

; ---------------
; MYPRIVATEROUTINE, called, when "$" is in a macro.
; gets pointer to itself in a0, and called-count.w in d0
; SHOULD NOT TAKE THAT LONG (called from a VERY time critical level4 int!!!)
myprivateroutine:
 move.w #$0f00,$dff180
 rts                       ; always ends up by this !

; ---------------

instrslength:   dc.l 0
realinstrslen:  dc.l 0
macroslength:   dc.l 0
instrdata:      dc.l 0
realinstrdata:  dc.l 0
macrosdata:     dc.l 0
mixbufferstart: dc.l 0
tablemem:       dc.l 0
mixbuflen:      dc.l 0
ifilenameendptr: dc.l 0
packedflag:     dc.b 0
 cnop 0,2
dosbase:        dc.l 0
intbase:        dc.l 0
argc:           dc.l 0

dosname:        dc.b 'dos.library',0
intname:        dc.b 'intuition.library',0
 cnop 0,2

window:    dc.l 0
userport:  dc.l 0
mywindow:
 dc.w 387,0,200,21,$0201
 dc.l $00000240,$0003000e,firstgadget,0,mytitle,0,0
 dc.w 0,0,0,0,$0001
windowtags: dc.l $80000077,21-10,0,0
 cnop 0,4
procname: 
mytitle: dc.b '8Player',0
 cnop 0,2
firstgadget:
 dc.l 0
 dc.w (8*7)+8,12-21,132,$0006,$000b,$0001,$0003
 dc.l gadgetrender1,0,text1,0,prop1
 dc.w $0001,0,0
prop1:
 dc.w $0013,$ffff,0,$0204,0,0,0,0,0,0,0,$0204,0,0
gadgetrender1:
 dc.w -2,-1,$0300,$0005
 dc.l xytable,0
xytable:
 dc.l $00000000,$00a700a7,$00070007,$00000007,$00000000
 cnop 0,2
text1:
 dc.w $0100,$0100,-((8*7)+4),-1
 dc.l mytextattr,text11,0
mytextattr:
 dc.l fontname
 dc.w 8,0
fontname: dc.b 'topaz.font',0
text11: dc.b 'Volume:',0
 cnop 0,2

audopen: dc.b 0

 cnop 0,4


 SECTION mybss,BSS

fileinfo:       ds.b 290
macrosfile:     ds.b 256
instrsfile:     ds.b 256
argvArray:      ds.l 10
argvBuffer:     ds.b 128

 END

