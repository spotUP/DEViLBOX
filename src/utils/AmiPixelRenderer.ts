/**
 * AmiPixelRenderer.ts — Amiga-style pixel-perfect canvas renderer
 * 
 * Ported from Ami-Sampler-VST PixelBuffer.cpp + ami_font.cpp + ami_palette.h
 * Renders into a Uint32Array backing buffer, then blits to canvas.
 * Uses nearest-neighbor scaling (CSS image-rendering: pixelated) for authentic look.
 */

// ============================================================================
// Amiga Palette (from ami_palette.h) — ABGR format for ImageData
// ============================================================================

// Convert 0xAARRGGBB → 0xAABBGGRR for ImageData (little-endian)
function argbToAbgr(c: number): number {
  const a = (c >> 24) & 0xFF;
  const r = (c >> 16) & 0xFF;
  const g = (c >> 8) & 0xFF;
  const b = c & 0xFF;
  return (a << 24) | (b << 16) | (g << 8) | r;
}

// Colors in ARGB (same as C++ source)
export const AMI_COLORS_ARGB = {
  BLU: 0xFF0054AA,   // Main blue
  BLL: 0xFF006ADD,   // Light blue (bevel highlight)
  BLD: 0xFF002049,   // Dark blue (bevel shadow)
  ORG: 0xFFFC8A00,   // Orange (accents)
  WHT: 0xFFFFFFFF,   // White
  BLK: 0xFF000000,   // Black
  GRY: 0xFF9E9E9E,   // Grey (buttons)
  RED: 0xFFC92D28,   // Red (LED)
  YLW: 0xFFF9D800,   // Yellow
  TRACK_LT: 0xFF00449A,  // Slider track light
  TRACK_DK: 0xFF00113D,  // Slider track dark
} as const;

// Pre-converted to ABGR for ImageData
export const AMI = {
  BLU: argbToAbgr(AMI_COLORS_ARGB.BLU),
  BLL: argbToAbgr(AMI_COLORS_ARGB.BLL),
  BLD: argbToAbgr(AMI_COLORS_ARGB.BLD),
  ORG: argbToAbgr(AMI_COLORS_ARGB.ORG),
  WHT: argbToAbgr(AMI_COLORS_ARGB.WHT),
  BLK: argbToAbgr(AMI_COLORS_ARGB.BLK),
  GRY: argbToAbgr(AMI_COLORS_ARGB.GRY),
  RED: argbToAbgr(AMI_COLORS_ARGB.RED),
  YLW: argbToAbgr(AMI_COLORS_ARGB.YLW),
  TRACK_LT: argbToAbgr(AMI_COLORS_ARGB.TRACK_LT),
  TRACK_DK: argbToAbgr(AMI_COLORS_ARGB.TRACK_DK),
} as const;

// CSS hex colors for React/DOM elements
export const AMI_CSS = {
  BLU: '#0054AA',
  BLL: '#006ADD',
  BLD: '#002049',
  ORG: '#FC8A00',
  WHT: '#FFFFFF',
  BLK: '#000000',
  GRY: '#9E9E9E',
  RED: '#C92D28',
  YLW: '#F9D800',
} as const;

// ============================================================================
// 8x8 Bitmap Font (from ami_font.cpp)
// ASCII 0x21 ('!') through 0x7E ('~') = 94 characters
// Each character is 8 bytes, each byte is one row, bit 7 = leftmost pixel
// ============================================================================

// prettier-ignore
const FONT_DATA: number[] = [
  // ! (0x21)
  0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x00,
  // " (0x22)
  0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x30,
  // # (0x23)
  0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00,
  // $ (0x24)
  0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00,
  // % (0x25)
  0x00,0x66,0xAC,0xD8,0x36,0x6A,0xCC,0x00,
  // & (0x26)
  0x38,0x6C,0x68,0x76,0xDC,0xCE,0x7F,0x00,
  // ' (0x27)
  0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00,
  // ( (0x28)
  0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,
  // ) (0x29)
  0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,
  // * (0x2A)
  0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,
  // + (0x2B)
  0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,
  // , (0x2C)
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,
  // - (0x2D)
  0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
  // . (0x2E)
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,
  // / (0x2F)
  0x03,0x06,0x0C,0x18,0x30,0x60,0xC0,0x00,
  // 0-9 (0x30-0x39)
  0x3C,0x66,0x6E,0x7E,0x76,0x66,0x3C,0x00,
  0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x00,
  0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00,
  0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,
  0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x00,
  0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,
  0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,
  0x7E,0x06,0x06,0x0C,0x18,0x18,0x18,0x00,
  0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,
  0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,
  // : (0x3A)
  0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,
  // ; (0x3B)
  0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30,
  // < (0x3C)
  0x00,0x06,0x18,0x60,0x18,0x06,0x00,0x00,
  // = (0x3D)
  0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,
  // > (0x3E)
  0x00,0x60,0x18,0x06,0x18,0x60,0x00,0x00,
  // ? (0x3F)
  0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00,
  // @ (0x40)
  0x7C,0xC6,0xDE,0xD6,0xDE,0xC0,0x78,0x00,
  // A-Z (0x41-0x5A)
  0x3C,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
  0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00,
  0x1E,0x30,0x60,0x60,0x60,0x30,0x1E,0x00,
  0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00,
  0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00,
  0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x00,
  0x3C,0x66,0x60,0x6E,0x66,0x66,0x3E,0x00,
  0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
  0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
  0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00,
  0xC6,0xCC,0xD8,0xF0,0xD8,0xCC,0xC6,0x00,
  0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,
  0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00,
  0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00,
  0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
  0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,
  0x78,0xCC,0xCC,0xCC,0xCC,0xDC,0x7E,0x00,
  0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00,
  0x3C,0x66,0x70,0x3C,0x0E,0x66,0x3C,0x00,
  0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
  0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
  0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,
  0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00,
  0xC3,0x66,0x3C,0x18,0x3C,0x66,0xC3,0x00,
  0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x00,
  0xFE,0x0C,0x18,0x30,0x60,0xC0,0xFE,0x00,
  // [ (0x5B)
  0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,
  // \ (0x5C)
  0xC0,0x60,0x30,0x18,0x0C,0x06,0x03,0x00,
  // ] (0x5D)
  0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,
  // ^ (0x5E)
  0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,
  // _ (0x5F)
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,
  // ` (0x60)
  0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,
  // a-z (0x61-0x7A)
  0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00,
  0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,
  0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00,
  0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,
  0x00,0x00,0x3C,0x66,0x7C,0x60,0x3C,0x00,
  0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00,
  0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C,
  0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00,
  0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,
  0x06,0x00,0x06,0x06,0x06,0x06,0x06,0x3C,
  0x60,0x60,0x66,0x6C,0x7C,0x6C,0x66,0x00,
  0x18,0x18,0x18,0x18,0x18,0x18,0x0C,0x00,
  0x00,0x00,0xEC,0xFE,0xD6,0xC6,0xC6,0x00,
  0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
  0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
  0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
  0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
  0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00,
  0x00,0x00,0x3C,0x60,0x3C,0x0E,0x7C,0x00,
  0x60,0x60,0x7C,0x60,0x60,0x60,0x3C,0x00,
  0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
  0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
  0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00,
  0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00,
  0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x30,
  0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00,
  // { (0x7B)
  0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00,
  // | (0x7C)
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
  // } (0x7D)
  0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00,
  // ~ (0x7E)
  0x71,0x8E,0x00,0x00,0x00,0x00,0x00,0x00,
];

// ============================================================================
// PixelBuffer — software pixel framebuffer (from PixelBuffer.cpp)
// ============================================================================

export class AmiPixelBuffer {
  readonly width: number;
  readonly height: number;
  private pixels: Uint32Array;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
    this.pixels = new Uint32Array(width * height);
  }

  clear(color: number = AMI.BLK): void {
    this.pixels.fill(color);
  }

  setPixel(x: number, y: number, c: number): void {
    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
      this.pixels[x + y * this.width] = c;
    }
  }

  // Bresenham line drawing (from PixelBuffer.cpp::draw_line)
  drawLine(x1: number, y1: number, x2: number, y2: number, c: number): void {
    x1 = Math.round(x1); y1 = Math.round(y1);
    x2 = Math.round(x2); y2 = Math.round(y2);

    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const sx = x1 < x2 ? 1 : -1;
    const sy = y1 < y2 ? 1 : -1;
    let error = dx - dy;

    while (true) {
      this.setPixel(x1, y1, c);
      if (x1 === x2 && y1 === y2) break;
      const e2 = 2 * error;
      if (e2 > -dy) { error -= dy; x1 += sx; }
      if (e2 < dx) { error += dx; y1 += sy; }
    }
  }

  drawHLine(x: number, y: number, w: number, c: number): void {
    if (y < 0 || y >= this.height) return;
    const start = Math.max(0, x);
    const end = Math.min(this.width, x + w);
    const offset = y * this.width;
    for (let i = start; i < end; i++) {
      this.pixels[offset + i] = c;
    }
  }

  drawVLine(x: number, y: number, h: number, c: number): void {
    if (x < 0 || x >= this.width) return;
    const start = Math.max(0, y);
    const end = Math.min(this.height, y + h);
    for (let i = start; i < end; i++) {
      this.pixels[x + i * this.width] = c;
    }
  }

  fillRect(x: number, y: number, w: number, h: number, c: number): void {
    const x0 = Math.max(0, x);
    const y0 = Math.max(0, y);
    const x1 = Math.min(this.width, x + w);
    const y1 = Math.min(this.height, y + h);
    for (let row = y0; row < y1; row++) {
      const offset = row * this.width;
      for (let col = x0; col < x1; col++) {
        this.pixels[offset + col] = c;
      }
    }
  }

  drawRect(x: number, y: number, w: number, h: number, c: number): void {
    this.drawHLine(x, y, w, c);
    this.drawHLine(x, y + h - 1, w, c);
    this.drawVLine(x, y, h, c);
    this.drawVLine(x + w - 1, y, h, c);
  }

  // 3D beveled rect (Amiga-style raised button)
  drawBevelRect(x: number, y: number, w: number, h: number, fill: number, pressed: boolean): void {
    this.fillRect(x, y, w, h, fill);

    if (pressed) {
      // Pressed: dark edges on top+left
      for (let i = 0; i < 2; i++) {
        this.drawHLine(x + i, y + i, w - i, AMI.BLD);
        this.drawVLine(x + i, y + i, h - i, AMI.BLD);
      }
    } else {
      // Raised: bright top+left, dark bottom+right
      for (let i = 0; i < 2; i++) {
        this.drawHLine(x + i, y + i, w - i * 2, AMI.BLL);
        this.drawVLine(x + i, y + i, h - i * 2, AMI.BLL);
        this.drawHLine(x + i, y + h - 1 - i, w - i * 2, AMI.BLD);
        this.drawVLine(x + w - 1 - i, y + i, h - i * 2, AMI.BLD);
      }
    }

    // Black border
    this.drawRect(x, y, w, h, AMI.BLK);
  }

  // Print a single 8x8 character (from PixelBuffer.cpp::print_font)
  printChar(ch: string, x: number, y: number, color: number, scale: number = 1): void {
    const code = ch.charCodeAt(0);
    if (code < 0x21 || code > 0x7E) return; // space or unprintable
    const idx = (code - 0x21) * 8;

    for (let row = 0; row < 8; row++) {
      const byte = FONT_DATA[idx + row];
      for (let col = 0; col < 8; col++) {
        if (byte & (1 << (7 - col))) {
          if (scale === 1) {
            this.setPixel(x + col, y + row, color);
          } else {
            this.fillRect(x + col * scale, y + row * scale, scale, scale, color);
          }
        }
      }
    }
  }

  // Print a string (from PixelBuffer.cpp::print_string)
  printString(text: string, x: number, y: number, color: number, scale: number = 1): void {
    const charWidth = 8 * scale;
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      if (ch !== ' ') {
        this.printChar(ch, x + i * charWidth, y, color, scale);
      }
    }
  }

  // Draw waveform — connected lines mode (zoomed in)
  drawWaveLines(data: Float32Array, startSample: number, endSample: number,
    waveX: number, waveY: number, waveW: number, waveH: number, color: number): void {
    const numSamples = endSample - startSample;
    if (numSamples <= 0 || waveW <= 0) return;

    const halfH = waveH / 2;
    const centerY = waveY + halfH;

    let prevX = waveX;
    let prevY = centerY - Math.round(data[startSample] * halfH);

    for (let px = 1; px < waveW; px++) {
      const sampleIdx = startSample + Math.floor((px / waveW) * numSamples);
      const idx = Math.min(sampleIdx, data.length - 1);
      const curX = waveX + px;
      const curY = centerY - Math.round(data[idx] * halfH);

      this.drawLine(prevX, prevY, curX, curY, color);
      prevX = curX;
      prevY = curY;
    }
  }

  // Draw waveform — min/max polygon mode (zoomed out)
  drawWavePolygons(data: Float32Array, startSample: number, endSample: number,
    waveX: number, waveY: number, waveW: number, waveH: number, color: number): void {
    const numSamples = endSample - startSample;
    if (numSamples <= 0 || waveW <= 0) return;

    const halfH = waveH / 2;
    const centerY = waveY + halfH;
    const samplesPerPixel = numSamples / waveW;

    for (let px = 0; px < waveW; px++) {
      const s0 = startSample + Math.floor(px * samplesPerPixel);
      const s1 = Math.min(startSample + Math.floor((px + 1) * samplesPerPixel), endSample);

      let minVal = 1, maxVal = -1;
      for (let s = s0; s < s1 && s < data.length; s++) {
        if (data[s] < minVal) minVal = data[s];
        if (data[s] > maxVal) maxVal = data[s];
      }

      const y0 = centerY - Math.round(maxVal * halfH);
      const y1 = centerY - Math.round(minVal * halfH);

      this.drawVLine(waveX + px, Math.min(y0, y1), Math.abs(y1 - y0) + 1, color);
    }
  }

  // Auto-select draw mode based on zoom level
  drawWaveform(data: Float32Array, startSample: number, endSample: number,
    waveX: number, waveY: number, waveW: number, waveH: number, color: number): void {
    const numSamples = endSample - startSample;
    if (numSamples <= waveW) {
      this.drawWaveLines(data, startSample, endSample, waveX, waveY, waveW, waveH, color);
    } else {
      this.drawWavePolygons(data, startSample, endSample, waveX, waveY, waveW, waveH, color);
    }
  }

  // Blit to a canvas 2D context as ImageData
  blitToCanvas(ctx: CanvasRenderingContext2D): void {
    const imageData = ctx.createImageData(this.width, this.height);
    const u8 = new Uint8Array(this.pixels.buffer);
    imageData.data.set(u8);
    ctx.putImageData(imageData, 0, 0);
  }
}
